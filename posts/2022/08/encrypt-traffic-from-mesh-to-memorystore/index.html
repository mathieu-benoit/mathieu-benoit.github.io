<!doctype html><html lang=en><head><title>seamlessly encrypt traffic from any apps in your mesh to memorystore (redis) ::
always up, always on</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Update on Sep 8th, 2022: this blog article is now on Medium.
Note: this blog article is an end-to-end recipe implementing the Istio TLS origination to secure Memorystore (redis) access blog article I wrote a few months ago.
Anthos Service Mesh (ASM), a managed Istio implementation, can improve your security posture for your Kubernetes clusters and your apps. Istio aims to bring as much value to users out of the box without any configuration at all."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://mathieu-benoit.github.io/posts/2022/08/encrypt-traffic-from-mesh-to-memorystore/><link rel=stylesheet href=https://mathieu-benoit.github.io/assets/style.css><link rel=stylesheet href=https://mathieu-benoit.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://mathieu-benoit.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://mathieu-benoit.github.io/img/favicon.png><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="seamlessly encrypt traffic from any apps in your mesh to memorystore (redis)"><meta name=twitter:description content="let's see how to use anthos service mesh to seamlessly encrypt traffic between any apps and memorystore (redis)."><meta property="og:title" content="seamlessly encrypt traffic from any apps in your mesh to memorystore (redis)"><meta property="og:description" content="let's see how to use anthos service mesh to seamlessly encrypt traffic between any apps and memorystore (redis)."><meta property="og:type" content="article"><meta property="og:url" content="https://mathieu-benoit.github.io/posts/2022/08/encrypt-traffic-from-mesh-to-memorystore/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-29T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-29T00:00:00+00:00"><meta property="og:site_name" content="always up, always on"><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>seamlessly encrypt traffic from any apps in your mesh to memorystore (redis)</h1><div class=post-meta><span class=post-date>2022-08-29</span></div><span class=post-tags><a href=https://mathieu-benoit.github.io/tags/gcp/>#gcp</a>&nbsp;
<a href=https://mathieu-benoit.github.io/tags/kubernetes/>#kubernetes</a>&nbsp;
<a href=https://mathieu-benoit.github.io/tags/security/>#security</a>&nbsp;
<a href=https://mathieu-benoit.github.io/tags/service-mesh/>#service-mesh</a>&nbsp;</span><div class=post-content><p><em>Update on Sep 8th, 2022: this blog article is now on <a href=https://medium.com/google-cloud/64b71969318d>Medium</a>.</em></p><p><em>Note: this blog article is an end-to-end recipe implementing the <a href=https://mathieu-benoit.github.io/posts/2022/01/istio-tls-origination/>Istio TLS origination to secure Memorystore (redis) access</a> blog article I wrote a few months ago.</em></p><p>Anthos Service Mesh (ASM), a managed Istio implementation, can <a href=https://cloud.google.com/service-mesh/docs/security/anthos-service-mesh-security-best-practices>improve your security posture</a> for your Kubernetes clusters and your apps. Istio aims to bring <a href=https://istio.io/latest/blog/2021/zero-config-istio/>as much value to users out of the box</a> without any configuration at all. ASM, on top of that, simplifies all the management of both the control plane and the data plane and the integration with monitoring and logging. Without any compromise, your apps in your Mesh will benefit from advanced features like traffic encryption, logging, tracing, etc. without updating the code of your apps.</p><p>In this article, we will show how easy and seamless it is to encrypt traffic from the Online Boutique sample apps to Memorystore (redis) by leveraging Anthos Service Mesh (ASM).</p><p><img src=https://github.com/mathieu-benoit/my-images/raw/main/encrypt-traffic-from-mesh-to-memorystore.png alt="Architecture overview."></p><h2 id=objectives>Objectives
<a href=#objectives class=h-anchor aria-hidden=true>#</a></h2><ul><li>Create a Google Kubernetes Engine (GKE) cluster</li><li>Deploy the Online Boutique sample apps with an in-cluster redis database</li><li>Provision a Memorystore (redis) instance allowing only in-transit encryption</li><li>Connect the Online Boutique sample apps to the Memorystore (redis) instance</li><li>Install the managed Anthos Service Mesh (ASM) on this cluster</li><li>Configure the TLS origination from the Mesh to the Memorystore (redis) instance</li><li>Verify that the Online Boutique sample apps is successfully communicating over TLS with the Memorystore (redis) instance</li></ul><h2 id=costs>Costs
<a href=#costs class=h-anchor aria-hidden=true>#</a></h2><p>This tutorial uses billable components of Google Cloud, including the following:</p><ul><li><a href=https://cloud.google.com/kubernetes-engine/pricing>Kubernetes Engine</a></li><li><a href=https://cloud.google.com/service-mesh/pricing>Anthos Service Mesh</a></li><li><a href=https://cloud.google.com/memorystore/docs/redis/pricing>Memorystore (redis)</a></li></ul><p>Use the <a href=https://cloud.google.com/products/calculator>pricing calculator</a> to generate a cost estimate based on your projected usage.</p><h2 id=before-you-begin>Before you begin
<a href=#before-you-begin class=h-anchor aria-hidden=true>#</a></h2><p>This guide assumes that you have owner IAM permissions for your Google Cloud project. In production, you do not require owner permission.</p><ol><li><p><a href=https://console.cloud.google.com/projectselector2>Select or create a Google Cloud project</a>.</p></li><li><p><a href=https://cloud.google.com/billing/docs/how-to/modify-project>Verify that billing is enabled</a> for your project.</p></li></ol><h2 id=set-up-your-environment>Set up your environment
<a href=#set-up-your-environment class=h-anchor aria-hidden=true>#</a></h2><p>Initialize the common variables used throughout this tutorial:</p><pre tabindex=0><code>PROJECT_ID=FIXME-WITH-YOUR-PROJECT-ID
REGION=us-east4
ZONE=us-east4-a
PROJECT_NUMBER=$(gcloud projects describe ${PROJECT_ID} --format=&#39;get(projectNumber)&#39;)
</code></pre><p>To avoid repeating the <code>--project</code> in the commands throughout this tutorial, let&rsquo;s set the current project:</p><pre tabindex=0><code>gcloud config set project ${PROJECT_ID}
</code></pre><h2 id=enable-the-required-apis-in-your-project>Enable the required APIs in your project
<a href=#enable-the-required-apis-in-your-project class=h-anchor aria-hidden=true>#</a></h2><p>Enable the required APIs in your project:</p><pre tabindex=0><code>gcloud services enable \
    redis.googleapis.com \
    mesh.googleapis.com
</code></pre><h2 id=create-a-gke-cluster>Create a GKE cluster
<a href=#create-a-gke-cluster class=h-anchor aria-hidden=true>#</a></h2><p>Create a GKE cluster:</p><pre tabindex=0><code>CLUSTER=redis-tls-tutorial
gcloud container clusters create ${CLUSTER} \
    --zone ${ZONE} \
    --machine-type=e2-standard-4 \
    --num-nodes 4 \
    --workload-pool ${PROJECT_ID}.svc.id.goog \
    --labels mesh_id=proj-${PROJECT_NUMBER} \
    --network default
</code></pre><h2 id=deploy-the-online-boutique-sample-apps>Deploy the Online Boutique sample apps
<a href=#deploy-the-online-boutique-sample-apps class=h-anchor aria-hidden=true>#</a></h2><p>Create a dedicated <code>Namespace</code>:</p><pre tabindex=0><code>NAMESPACE=onlineboutique
kubectl create ns ${NAMESPACE}
</code></pre><p>Deploy the Online Boutique sample apps:</p><pre tabindex=0><code>kubectl apply \
    -f https://raw.githubusercontent.com/GoogleCloudPlatform/microservices-demo/main/release/kubernetes-manifests.yaml \
    -n ${NAMESPACE}
</code></pre><p>After all the apps are successfully deployed, you could navigate to the Online Boutique website by clicking on the link below:</p><pre tabindex=0><code>echo -n &#34;http://&#34; &amp;&amp; kubectl get svc frontend-external -n ${NAMESPACE} -o json | jq -r &#39;.status.loadBalancer.ingress[0].ip&#39;
</code></pre><h2 id=provision-a-memorystore-redis-instance-allowing-only-in-transit-encryption>Provision a Memorystore (redis) instance allowing only in-transit encryption
<a href=#provision-a-memorystore-redis-instance-allowing-only-in-transit-encryption class=h-anchor aria-hidden=true>#</a></h2><p>Provision the Memorystore (redis) instance allowing only in-transit encryption:</p><pre tabindex=0><code>REDIS_NAME=redis-tls-tutorial
gcloud redis instances create ${REDIS_NAME} \
    --size 1 \
    --region ${REGION} \
    --zone ${ZONE} \
    --redis-version redis_6_x \
    --network default \
    --transit-encryption-mode SERVER_AUTHENTICATION
</code></pre><p>Notes:</p><ul><li>You can connect to a Memorystore (redis) instance from GKE clusters that are in the same region and use the same network as your instance.</li><li>You cannot connect to a Memorystore (redis) instance from a GKE cluster without VPC-native/IP aliasing enabled.</li><li>In-transit encryption is only available at creation time of your Memorystore (redis) instance. The Certificate Authority is valid for 10 years, <a href=https://cloud.google.com/memorystore/docs/redis/in-transit-encryption#certificate_authority_rotation>rotation every 5 years</a>.</li></ul><p>Wait for the Memorystore (redis) instance to be succesfully provisioned and get the connection information of the Memorystore (redis) instance just provisioned, we will need these information in a following section:</p><pre tabindex=0><code>REDIS_IP=$(gcloud redis instances describe ${REDIS_NAME} \
    --region ${REGION} \
    --format &#39;get(host)&#39;)
REDIS_PORT=$(gcloud redis instances describe ${REDIS_NAME} \
    --region ${REGION} \
    --format &#39;get(port)&#39;)
gcloud redis instances describe ${REDIS_NAME} \
    --region ${REGION} \
    --format &#39;get(serverCaCerts[0].cert)&#39; &gt; redis-cert.pem
</code></pre><h2 id=connect-the-online-boutique-sample-apps-to-the-memorystore-redis-instance>Connect the Online Boutique sample apps to the Memorystore (redis) instance
<a href=#connect-the-online-boutique-sample-apps-to-the-memorystore-redis-instance class=h-anchor aria-hidden=true>#</a></h2><p>Update the <code>cartservice</code>&rsquo;s environment variables to point to the Memorystore (redis) instance:</p><pre tabindex=0><code>kubectl set env deployment/cartservice REDIS_ADDR=${REDIS_IP}:${REDIS_PORT} \
    -n ${NAMESPACE}
</code></pre><p>Remove the default in-cluster <code>redis</code> database you won&rsquo;t use anymore:</p><pre tabindex=0><code>kubectl delete service redis-cart \
    -n ${NAMESPACE}
kubectl delete deployment redis-cart \
    -n ${NAMESPACE}
</code></pre><p>Navigate to the Online Boutique website by clicking on the link below:</p><pre tabindex=0><code>echo -n &#34;http://&#34; &amp;&amp; kubectl get svc frontend-external -n ${NAMESPACE} -o json | jq -r &#39;.status.loadBalancer.ingress[0].ip&#39;
</code></pre><p>You should have a <code>HTTP Status: 500 Internal Server Error</code> page at this point. This is expected since we haven&rsquo;t yet set up the TLS communication between <code>cartservice</code> and the Memorystore (redis) instance. With the next sections, we will leverage ASM and Istio in order to accomplish this part.</p><h2 id=install-the-managed-asm-on-this-cluster>Install the managed ASM on this cluster
<a href=#install-the-managed-asm-on-this-cluster class=h-anchor aria-hidden=true>#</a></h2><p>Register your cluster to a <a href=https://cloud.google.com/anthos/fleet-management/docs/fleet-concepts>Fleet</a>:</p><pre tabindex=0><code>gcloud container fleet memberships register ${CLUSTER} \
    --gke-cluster ${ZONE}/${CLUSTER} \
    --enable-workload-identity
</code></pre><p>Enable ASM in your <a href=https://cloud.google.com/anthos/fleet-management/docs/fleet-concepts>Fleet</a>:</p><pre tabindex=0><code>gcloud container fleet mesh enable
</code></pre><p>Enable the ASM automatic control plane management to let Google apply the recommended configuration of ASM:</p><pre tabindex=0><code>gcloud container fleet mesh update \
    --control-plane automatic \
    --memberships ${CLUSTER}
</code></pre><h2 id=configure-the-tls-origination-from-the-mesh-to-the-memorystore-redis-instance>Configure the TLS origination from the Mesh to the Memorystore (redis) instance
<a href=#configure-the-tls-origination-from-the-mesh-to-the-memorystore-redis-instance class=h-anchor aria-hidden=true>#</a></h2><p>Create a <code>Secret</code> with the Certificate Authority generated previously:</p><pre tabindex=0><code>kubectl create secret generic redis-cert \
    --from-file redis-cert.pem \
    -n ${NAMESPACE}
</code></pre><p>Annotate the <code>cartservice</code> deployment to mount the <code>redis-cert</code> secret via its <code>istio-proxy</code> sidecar:</p><pre tabindex=0><code>kubectl patch deployment cartservice \
    -n ${NAMESPACE} \
    -p &#39;{&#34;spec&#34;: {&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;sidecar.istio.io/userVolumeMount&#34;:&#34;[{\&#34;name\&#34;:\&#34;redis-cert\&#34;, \&#34;mountPath\&#34;:\&#34;/etc/certs\&#34;, \&#34;readonly\&#34;:true}]&#34;}}}} }&#39;
kubectl patch deployment cartservice \
    -n ${NAMESPACE} \
    -p &#39;{&#34;spec&#34;: {&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;sidecar.istio.io/userVolume&#34;:&#34;[{\&#34;name\&#34;:\&#34;redis-cert\&#34;, \&#34;secret\&#34;:{\&#34;secretName\&#34;:\&#34;redis-cert\&#34;}}]&#34;}}}} }&#39;
</code></pre><p>From there we could create <code>ServiceEntry</code> and <code>DestinationRule</code> allowing to expose this external endpoint in the mesh with a TLS origination setup:</p><pre tabindex=0><code>INTERNAL_HOST=redis.memorystore-redis
cat &lt;&lt;EOF | kubectl apply -n ${NAMESPACE} -f -
apiVersion: networking.istio.io/v1beta1
kind: ServiceEntry
metadata:
  name: external-redis
spec:
  hosts:
  - ${INTERNAL_HOST}
  addresses:
  - ${REDIS_IP}/32
  endpoints:
  - address: ${REDIS_IP}
  location: MESH_EXTERNAL
  resolution: STATIC
  ports:
  - number: ${REDIS_PORT}
    name: tcp-redis
    protocol: TCP
EOF
cat &lt;&lt;EOF | kubectl apply -n ${NAMESPACE} -f -
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: external-redis
spec:
  exportTo:
  - &#39;.&#39;
  host: ${INTERNAL_HOST}
  trafficPolicy:
    tls:
      mode: SIMPLE
      caCertificates: /etc/certs/redis-cert.pem
EOF
</code></pre><p>Inject the Istio/ASM sidecar proxies in the Online Boutique <code>Namespace</code>:</p><pre tabindex=0><code>kubectl label namespace ${NAMESPACE} istio-injection=enabled
</code></pre><p>Wait for ASM to be properly installed on your cluster. Run this command below until you see the field <code>servicemesh.controlPlaneManagement.details[].code</code> with the value <code>REVISION_READY</code>:</p><pre tabindex=0><code>gcloud container fleet mesh describe
</code></pre><p>Restart the <code>cartservice</code> app in order to inject the Istio/ASM sidecar proxies and configs we just deployed previously:</p><pre tabindex=0><code>kubectl rollout restart deployment cartservice \
    -n ${NAMESPACE}
</code></pre><p>Navigate to the Online Boutique website by clicking on the link below:</p><pre tabindex=0><code>echo -n &#34;http://&#34; &amp;&amp; kubectl get svc frontend-external -n ${NAMESPACE} -o json | jq -r &#39;.status.loadBalancer.ingress[0].ip&#39;
</code></pre><p>You should now see the Online Boutique website working successfully again, now connected to the Memorystore (redis) instance.</p><h2 id=cleaning-up>Cleaning up
<a href=#cleaning-up class=h-anchor aria-hidden=true>#</a></h2><p>To avoid incurring charges to your Google Cloud account, you can delete the resources used in this tutorial.</p><p>Unregister the GKE cluster from the <a href=https://cloud.google.com/anthos/fleet-management/docs/fleet-concepts>Fleet</a>:</p><pre tabindex=0><code>gcloud container fleet memberships unregister ${CLUSTER} \
    --project=${PROJECT_ID} \
    --gke-cluster=${ZONE}/${CLUSTER}
</code></pre><p>Delete the GKE cluster:</p><pre tabindex=0><code>gcloud container clusters delete ${CLUSTER} \
    --zone ${ZONE}
</code></pre><p>Delete the Memorystore (redis) instance:</p><pre tabindex=0><code>gcloud redis instances delete ${REDIS_NAME}
</code></pre><h2 id=whats-next>What&rsquo;s next
<a href=#whats-next class=h-anchor aria-hidden=true>#</a></h2><ul><li>Watch this <a href=https://youtu.be/C1y_Ix3ws68>ASM value over Istio OSS</a> episode on YouTube.</li><li>Learn more about <a href=https://cloud.google.com/service-mesh/docs/security/anthos-service-mesh-security-best-practices>ASM security best practices</a>.</li><li>Watch this <a href=https://youtu.be/D_TBDp9tK9w>Architecting zero trust networks with GKE and ASM</a> episode on YouTube</li><li>Learn more about <a href=https://cloud.google.com/service-mesh/docs/strengthen-app-security>Strengthen your app&rsquo;s security with ASM and Anthos Config Management</a>.</li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://mathieu-benoit.github.io/posts/2022/09/ci-gitops-helm-github-actions-github-registry/><span class=button__icon>←</span>
<span class=button__text>ci/gitops with helm, github actions, github container registry and config sync</span></a></span>
<span class="button next"><a href=https://mathieu-benoit.github.io/posts/2022/08/oci-config-sync/><span class=button__text>gitops with oci artifacts and config sync</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2023 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://mathieu-benoit.github.io/assets/main.js></script>
<script src=https://mathieu-benoit.github.io/assets/prism.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></body></html>