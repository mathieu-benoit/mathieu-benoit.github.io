<!doctype html><html lang=en><head><title>istio tls origination to secure memorystore (redis) access ::
always up, always on</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="I recently watched this IstioCon 2021 session: Redis TLS Origination with the sidecar.
Very inspiring. Without any change in the code of your apps you could configure Istio to help you do the encrypted connection to an external redis instance. Wow! More security, less impact for developers!
TLS origination occurs when an Istio proxy (sidecar or egress gateway) is configured to accept unencrypted internal HTTP connections, encrypt the requests, and then forward them to HTTPS servers that are secured using simple or mutual TLS."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://mathieu-benoit.github.io/posts/2022/01/istio-tls-origination/><link rel=stylesheet href=https://mathieu-benoit.github.io/assets/style.css><link rel=stylesheet href=https://mathieu-benoit.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://mathieu-benoit.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://mathieu-benoit.github.io/img/favicon.png><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="istio tls origination to secure memorystore (redis) access"><meta name=twitter:description content="let's see how we could secure the access of memorystore (redis) via istio tls origination, without changing any code in the application"><meta property="og:title" content="istio tls origination to secure memorystore (redis) access"><meta property="og:description" content="let's see how we could secure the access of memorystore (redis) via istio tls origination, without changing any code in the application"><meta property="og:type" content="article"><meta property="og:url" content="https://mathieu-benoit.github.io/posts/2022/01/istio-tls-origination/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-16T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-16T00:00:00+00:00"><meta property="og:site_name" content="always up, always on"><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>istio tls origination to secure memorystore (redis) access</h1><div class=post-meta><span class=post-date>2022-01-16</span></div><span class=post-tags><a href=https://mathieu-benoit.github.io/tags/gcp/>#gcp</a>&nbsp;
<a href=https://mathieu-benoit.github.io/tags/service-mesh/>#service-mesh</a>&nbsp;
<a href=https://mathieu-benoit.github.io/tags/kubernetes/>#kubernetes</a>&nbsp;
<a href=https://mathieu-benoit.github.io/tags/security/>#security</a>&nbsp;</span><div class=post-content><p>I recently watched this <a href=https://events.istio.io/istiocon-2021/sessions/redis-tls-origination-with-the-sidecar/>IstioCon 2021 session: Redis TLS Origination with the sidecar</a>.</p><p>Very inspiring. Without any change in the code of your apps you could configure Istio to help you do the encrypted connection to an external redis instance. Wow! More security, less impact for developers!</p><blockquote><p><a href=https://istio.io/latest/docs/tasks/traffic-management/egress/egress-tls-origination/#tls-origination-for-egress-traffic>TLS origination</a> occurs when an Istio proxy (sidecar or egress gateway) is configured to accept unencrypted internal HTTP connections, encrypt the requests, and then forward them to HTTPS servers that are secured using simple or mutual TLS. This is the opposite of TLS termination where an ingress proxy accepts incoming TLS connections, decrypts the TLS, and passes unencrypted requests on to internal mesh services.</p></blockquote><p>From this, my idea was about to secure the Memorystore (redis) access and again, without any code change, the <code>istio-proxy</code> of the application would transparently upgrade the connection to TLS.</p><blockquote><p><a href=https://cloud.google.com/memorystore/docs/redis/in-transit-encryption>Memorystore for Redis supports encrypting all Redis traffic</a> using the Transport Layer Security (TLS) protocol. When in-transit encryption is enabled Redis clients communicate exclusively across a secure port connection. Redis clients that are not configured for TLS will be blocked. If you choose to enable in-transit encryption you are responsible for ensuring that your Redis client is capable of using the TLS protocol.</p></blockquote><p>After some research and tests to adapt this IstioCon session to use Memorystore (redis), it turned out that there was 2 main differences:</p><ol><li>An <a href=https://cloud.google.com/memorystore/docs/redis/networking#supported_and_unsupported_networks>internal (private) IP address</a> is exposing the instance, there is no DNS.</li><li>A <a href=https://cloud.google.com/memorystore/docs/redis/in-transit-encryption#certificate_authority>Certificate Authority</a> should be installed on the client machine accessing the Redis instance.</li></ol><p>So here is the full step-by-step guide in order to make it working accordingly.</p><p>Let&rsquo;s create a Memorystore (redis) instance allowing only in-transit encryption:</p><pre tabindex=0><code>GKE_REGION=us-east4
GKE_ZONE=us-east4-a
REDIS_NAME=redis-tls
gcloud redis instances create $REDIS_NAME --size=1 --region=$GKE_REGION --zone=$GKE_ZONE --redis-version=redis_6_x --transit-encryption-mode=SERVER_AUTHENTICATION
REDIS_IP=$(gcloud redis instances describe $REDIS_NAME --region=$GKE_REGION --format=&#39;get(host)&#39;)
REDIS_PORT=$(gcloud redis instances describe $REDIS_NAME --region=$GKE_REGION --format=&#39;get(port)&#39;)
gcloud redis instances describe $REDIS_NAME --region=$GKE_REGION --format=&#39;get(serverCaCerts[0].cert)&#39; &gt; redis-cert.pem
</code></pre><p>Notes:</p><ul><li>You can connect to a Memorystore (redis) instance from GKE clusters that are in the same region and use the same network as your instance.</li><li>You cannot connect to a Memorystore (redis) instance from a GKE cluster without VPC-native/IP aliasing enabled.</li><li>In-transit encryption is only available at creation time of your Memorystore (redis) instance. There is a <a href=https://cloud.google.com/memorystore/docs/redis/in-transit-encryption#connection_limits_for_in-transit_encryption>connections limit</a> when using it. The Certificate Authority is valid for 10 years, <a href=https://cloud.google.com/memorystore/docs/redis/in-transit-encryption#certificate_authority_rotation>rotation every 5 years</a>.</li></ul><p>Create the dedicated <code>Namespace</code> with Istio/ASM sidecar injection enabled:</p><pre tabindex=0><code>NAMESPACE=redis-tls
ISTIO_REV=FIXME
cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Namespace
metadata:
  name: ${NAMESPACE}
  labels:
    istio.io/rev: ${ISTIO_REV}
EOF
</code></pre><p>Create a <code>Secret</code> with the Certificate Authority generated previously:</p><pre tabindex=0><code>kubectl create secret generic redis-cert --from-file=redis-cert.pem -n $NAMESPACE
</code></pre><p>From there we could create <code>ServiceEntry</code> and <code>DestinationRule</code> allowing to expose this external endpoint in the mesh with a TLS origination setup:</p><pre tabindex=0><code>INTERNAL_HOST=redis.memorystore-redis
cat &lt;&lt;EOF | kubectl apply -n $NAMESPACE -f -
apiVersion: networking.istio.io/v1beta1
kind: ServiceEntry
metadata:
  name: external-redis
spec:
  hosts:
  - ${INTERNAL_HOST}
  addresses:
  - ${REDIS_IP}/32
  endpoints:
  - address: ${REDIS_IP}
  location: MESH_EXTERNAL
  resolution: STATIC
  ports:
  - number: ${REDIS_PORT}
    name: tcp-redis
    protocol: TCP
EOF
cat &lt;&lt;EOF | kubectl apply -n $NAMESPACE -f -
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: external-redis
spec:
  exportTo:
  - &#39;.&#39;
  host: ${INTERNAL_HOST}
  trafficPolicy:
    tls:
      mode: SIMPLE
      caCertificates: /etc/certs/redis-cert.pem
EOF
</code></pre><p>Now, let&rsquo;s actually deploy a client which will be able to mount the <code>redis-cert</code> secret via its <code>istio-proxy</code> sidecar:</p><pre tabindex=0><code>cat &lt;&lt; EOF | kubectl apply -n $NAMESPACE -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-client
  labels:
    app: redis-client
spec:
  selector:
    matchLabels:
      app: redis-client
  template:
    metadata:
      labels:
        app: redis-client
      annotations:
        sidecar.istio.io/userVolumeMount: &#39;[{&#34;name&#34;:&#34;redis-cert&#34;, &#34;mountPath&#34;:&#34;/etc/certs&#34;, &#34;readonly&#34;:true}]&#39;
        sidecar.istio.io/userVolume: &#39;[{&#34;name&#34;:&#34;redis-cert&#34;, &#34;secret&#34;:{&#34;secretName&#34;:&#34;redis-cert&#34;}}]&#39;
    spec:
      containers:
        - image: redis
          name: redis-client
          command: [ &#34;/bin/bash&#34;, &#34;-c&#34;, &#34;--&#34; ]
          args: [ &#34;while true; do sleep 30; done;&#34; ]
EOF
</code></pre><p>If you want to leverage the <a href=https://mathieu-benoit.github.io/posts/2021/12/istio-sidecar/><code>Sidecar</code> resource</a>, you will need to update it accordingly to have the <code>redis-client</code> pod able to talk to this new defined endpoint:</p><pre tabindex=0><code>cat &lt;&lt; EOF | kubectl apply -n $NAMESPACE -f -
apiVersion: networking.istio.io/v1beta1
kind: Sidecar
metadata:
  name: redis-client
spec:
  workloadSelector:
    labels:
      app: redis-client
  egress:
  - hosts:
    - &#34;istio-system/*&#34;
    - &#34;./${INTERNAL_HOST}&#34;
EOF
</code></pre><p>We could verify that we could see this endpoint now configured like this: <code>redis.memorystore-redis - 6378 - outbound - EDS - external-redis.redis-tls</code> by running this command:</p><pre tabindex=0><code>istioctl proxy-config clusters $(kubectl -n $NAMESPACE get pod -l app=redis-client -o jsonpath={.items..metadata.name}) -n $NAMESPACE
</code></pre><p>Let&rsquo;s now connect to this <code>redis</code> client in order to test our setup:</p><pre tabindex=0><code>kubectl exec -ti deploy/redis-client -c redis-client -n $NAMESPACE -- bash -c &#34;redis-cli -h $REDIS_IP -p $REDIS_PORT&#34;
</code></pre><p>From within that shell, you could type <code>ping</code> and you should receive <code>pong</code>.</p><p>That&rsquo;s it! That&rsquo;s a wrap!</p><p><em>Note: There might have some <a href=https://cloud.google.com/memorystore/docs/redis/in-transit-encryption#performance_impact_of_enabling_in-transit_encryption>performance impacts of enabling in-transit encryption</a>. You may want to do your own <a href=https://redis.io/topics/benchmarks>benchmarks tests</a> with your own applications and context.</em></p><p>Further and complementary resources:</p><ul><li><a href=https://samos-it.com/posts/securing-redis-istio-tls-origniation-termination.html>Securing Redis with Istio TLS origination</a></li><li><a href=https://istio.io/latest/blog/2018/egress-mongo/>Consuming External MongoDB Services</a></li><li><a href=https://istiobyexample.dev/databases/>Istio Traffic with Firestore Database</a></li><li><a href=https://medium.com/@kellydodson/e51f4535871d>Connecting to Memorystore for Redis with TLS & AUTH</a></li></ul><p>Hope you enjoyed this post and that you will be able to leverage it for your own context.</p><p>Sail safe out there, cheers!</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://mathieu-benoit.github.io/posts/2022/01/workload-identity-federation/><span class=button__icon>←</span>
<span class=button__text>keyless gcp authentication from github actions with workload identity federation</span></a></span>
<span class="button next"><a href=https://mathieu-benoit.github.io/posts/2021/12/gke-2021/><span class=button__text>gke and anthos in 2021, a year of innovations</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2024 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://mathieu-benoit.github.io/assets/main.js></script>
<script src=https://mathieu-benoit.github.io/assets/prism.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></body></html>