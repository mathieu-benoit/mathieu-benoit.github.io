<!doctype html><html lang=en><head><title>binary authorization on gke ::
always up, always on</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Binary Authorization is a deploy-time security control that ensures only trusted container images are deployed on Google Kubernetes Engine (GKE). With Binary Authorization, you can require images to be signed by trusted authorities during the development process and then enforce signature validation when deploying. By enforcing validation, you can gain tighter control over your container environment by ensuring only verified images are integrated into the build-and-release process.
The Binary Authorization and Container Analysis are based upon the open source projects:"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/2020/11/binauthz/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon.png><link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="binary authorization on gke"><meta name=twitter:description content="let's see how you can only run what you trust (tl;dr whitelisted registries and signed containers) on gke with binauthz"><meta property="og:title" content="binary authorization on gke"><meta property="og:description" content="let's see how you can only run what you trust (tl;dr whitelisted registries and signed containers) on gke with binauthz"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2020/11/binauthz/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-13T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-13T00:00:00+00:00"><meta property="og:site_name" content="always up, always on"><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>binary authorization on gke</h1><div class=post-meta><span class=post-date>2020-11-13</span></div><span class=post-tags><a href=/tags/gcp/>#gcp</a>&nbsp;
<a href=/tags/containers/>#containers</a>&nbsp;
<a href=/tags/kubernetes/>#kubernetes</a>&nbsp;
<a href=/tags/security/>#security</a>&nbsp;</span><div class=post-content><p><img src=https://storage.googleapis.com/gweb-cloudblog-publish/images/How_Voucher_simplifies_a_secure_supply_cha.max-1400x1400.jpg alt="6 steps of a CI/CD worklow showing 2 of the related to Binary Authorization: signing in container registry and validating at runtime on Kubernetes."></p><blockquote><p>Binary Authorization is a deploy-time security control that ensures only trusted container images are deployed on Google Kubernetes Engine (GKE). With Binary Authorization, you can require images to be signed by trusted authorities during the development process and then enforce signature validation when deploying. By enforcing validation, you can gain tighter control over your container environment by ensuring only verified images are integrated into the build-and-release process.</p></blockquote><p>The <a href=https://cloud.google.com/binary-authorization>Binary Authorization</a> and <a href=https://cloud.google.com/artifact-registry/docs/analysis>Container Analysis</a> are based upon the open source projects:</p><ul><li><a href=https://grafeas.io/>Grafeas</a> defines an API spec for managing metadata about software resources, such as container images, Virtual Machine (VM) images, JAR files, and scripts. You can use Grafeas to define and aggregate information about your project’s components.</li><li><a href=https://github.com/grafeas/kritis>Kritis</a> defines an API for ensuring a deployment is prevented unless the artifact (container image) is conformant to central policy and optionally has the necessary attestations present.</li></ul><p>5 simple steps to accomplish this:</p><ul><li><a href=#setup-your-gke-cluster>Setup your GKE cluster</a></li><li><a href=#apply-cluster-policies>Apply cluster policies</a></li><li><a href=#create-an-attestor>Create an attestor</a></li><li><a href=#create-an-attestation>Create an attestation</a></li><li><a href=#deploy-a-signed-container>Deploy a signed container</a></li></ul><h2 id=setup-your-gke-cluster>Setup your GKE cluster
<a href=#setup-your-gke-cluster class=h-anchor aria-hidden=true>#</a></h2><pre tabindex=0><code>projectId=FIXME
registryName=$location-docker.pkg.dev/$projectId/containers
gcloud config set project $projectId

gcloud services enable container.googleapis.com
gcloud services enable binaryauthorization.googleapis.com

gcloud container clusters create \
    --enable-binauthz

# You could also enable this feature on an existing cluster
gcloud container clusters update $clusterName \
    --enable-binauthz

# Deploy the hello-world container from DockerHub
kubectl create deployment hello-world \
    --image=hello-world:latest
kubectl get pods

# Deploy the hello-world container from your private container registry
docker pull hello-world:latest
docker tag hello-world:latest $registryName/hello-world:latest
gcloud auth configure-docker --quiet
docker push $registryName/hello-world:latest
kubectl create deployment hello-world \
    --image=$registryName/hello-world:latest
kubectl get pods
</code></pre><h2 id=apply-cluster-policies>Apply cluster policies
<a href=#apply-cluster-policies class=h-anchor aria-hidden=true>#</a></h2><p>Securing the cluster with a policy, as a policy creator:</p><pre tabindex=0><code># Get the default policy in place
gcloud container binauthz policy export &gt; policy.yaml
cat policy.yaml

# Find all the default additional global policies in place
gcloud container binauthz policy export --project=binauthz-global-policy

# Change the default evaluationMode by ALWAYS-DENY
sed -i &#34;s/evaluationMode: ALWAYS_ALLOW/evaluationMode: ALWAYS_DENY/g&#34; policy.yaml
gcloud container binauthz policy import policy.yaml

# Check that any new deployment will fail with &#34;Denied by default admission rule&#34; error message in events
kubectl create deployment hello-world \
    --image=hello-world:latest
kubectl get event
kubectl create deployment hello-world \
    --image=$registryName/hello-world:latest
kubectl get event

# Change the admissionWhitelistPatterns list by removing the redundant global policies and adding our own container registry
cat &gt; policy.yaml &lt;&lt; EOF
admissionWhitelistPatterns:
- namePattern: $registryName/*
defaultAdmissionRule:
  enforcementMode: ENFORCED_BLOCK_AND_AUDIT_LOG
  evaluationMode: ALWAYS_DENY
globalPolicyEvaluationMode: ENABLE
name: projects/$projectId/policy
EOF
gcloud container binauthz policy import policy.yaml

# Check that the DockerHub deployment will fail with &#34;Denied by default admission rule&#34; error message in events but in the other end, the $registryName/hello-world will work now
kubectl create deployment hello-world \
    --image=hello-world:latest
kubectl get event
kubectl create deployment hello-world \
    --image=$registryName/hello-world:latest
kubectl get pod
</code></pre><p>That&rsquo;s how easy it is to authorize or not container images from specific container registries on your GKE clusters. You could find <a href=https://cloud.google.com/binary-authorization/docs/example-policies>more policies examples here</a>. An interesting feature to be aware of is the <a href=https://cloud.google.com/binary-authorization/docs/enabling-dry-run>dry run mode</a> which checks policy compliance at Pod creation time but without actually blocking the Pod from being created. Less radical and more gradual way to integrate Binary authorization on your existing GKE clusters.</p><h2 id=create-an-attestor>Create an attestor
<a href=#create-an-attestor class=h-anchor aria-hidden=true>#</a></h2><p>We need to <a href=https://cloud.google.com/binary-authorization/docs/creating-attestors-cli>create an attestor</a>:</p><pre tabindex=0><code>deployerProjectId=FIXME
deployerProjectNumber=$(gcloud projects describe &#34;$deployerProjectId&#34; --format=&#34;value(projectNumber)&#34;)
attestorProjectId=FIXME
attestorProjectNumber=$(gcloud projects describe &#34;$attestorProjectId&#34; --format=&#34;value(projectNumber)&#34;)
deployerSa=&#34;service-$deployerProjectNumber@gcp-sa-binaryauthorization.iam.gserviceaccount.com&#34;
attestorSa=&#34;service-$attestorProjectNumber@gcp-sa-binaryauthorization.iam.gserviceaccount.com&#34;
# Create a Container Analysis note
noteId=NOTE_ID
noteUri=&#34;projects/$attestorProjectId/notes/$noteId&#34;
description=FIXME
cat &gt; /tmp/note_payload.json &lt;&lt; EOM
{
  &#34;name&#34;: &#34;$noteUri&#34;,
  &#34;attestation&#34;: {
    &#34;hint&#34;: {
      &#34;human_readable_name&#34;: &#34;$description&#34;
    }
  }
}
EOM
curl \
    -X POST \
    -H &#34;Content-Type: application/json&#34; \
    -H &#34;Authorization: Bearer $(gcloud auth print-access-token)&#34;  \
    -H &#34;x-goog-user-project: $attestorProjectId&#34; \
    --data-binary @/tmp/note_payload.json  \
    &#34;https://containeranalysis.googleapis.com/v1/projects/$attestorProjectId/notes/?noteId=$noteId&#34;
curl \
    -H &#34;Authorization: Bearer $(gcloud auth print-access-token)&#34;  \
    -H &#34;x-goog-user-project: $attestorProjectId&#34; \
    &#34;https://containeranalysis.googleapis.com/v1/projects/$attestorProjectId/notes/&#34;
# Set permissions on the note
cat &gt; /tmp/iam_request.json &lt;&lt; EOM
{
  &#34;resource&#34;: &#34;$noteUri&#34;,
  &#34;policy&#34;: {
    &#34;bindings&#34;: [
      {
        &#34;role&#34;: &#34;roles/containeranalysis.notes.occurrences.viewer&#34;,
        &#34;members&#34;: [
          &#34;serviceAccount:$attestorSa&#34;
        ]
      }
    ]
  }
}
EOM
curl -X POST  \
    -H &#34;Content-Type: application/json&#34; \
    -H &#34;Authorization: Bearer $(gcloud auth print-access-token)&#34; \
    -H &#34;x-goog-user-project: $attestorProjectId&#34; \
    --data-binary @/tmp/iam_request.json \
    &#34;https://containeranalysis.googleapis.com/v1/projects/$attestorProjectId/notes/noteId:setIamPolicy&#34;
# Generate a key pair
pricateKeyFile=&#34;/tmp/ec_private.pem&#34;
openssl ecparam -genkey -name prime256v1 -noout -out $pricateKeyFile
publicKeyFile=&#34;/tmp/ec_public.pem&#34;
openssl ec -in $pricateKeyFile -pubout -out $publicKeyFile
# Create the attestor
attestorName=FIXME
gcloud container binauthz attestors create $attestorName \
    --project $attestorProjectId \
    --attestation-authority-note $noteId \
    --attestation-authority-note-project $attestorProjectId
gcloud beta container binauthz attestors add-iam-policy-binding &#34;projects/$attestorProjectId/attestors/$attestorName&#34; \
    --member=&#34;serviceAccount:$deployerSa&#34; \
    --role=roles/binaryauthorization.attestorsVerifier
# Add the public key to the attestor via Cloud KMS
kmsKeyProjectId=FIXME
kmsKeyringName=my-binauthz-keyring
kmsKeyName=my-binauthz-kms-key-name
kmsKeyLocation=global
kmsKeyVersion=1
gcloud kms keyrings create $kmsKeyringName \
    --location $kmsKeyLocation
gcloud kms keys create $kmsKeyName \
    --location $kmsKeyLocation \
    --keyring $kmsKeyringName  \
    --purpose asymmetric-signing \
    --default-algorithm ec-sign-p256-sha256 \
    --protection-level software
gcloud container binauthz attestors public-keys add \
    --project $attestorProjectId \
    --attestor $attestorName \
    --keyversion-project $kmsKeyProjectId \
    --keyversion-location $kmsKeyLocation \
    --keyversion-keyring $kmsKeyringName \
    --keyversion-key $kmsKeyName \
    --keyversion $kmsKeyVersion
# Verify that the attestor was created
gcloud container binauthz attestors list \
    --project $attestorProjectId
</code></pre><h2 id=create-an-attestation>Create an attestation
<a href=#create-an-attestation class=h-anchor aria-hidden=true>#</a></h2><p>Let&rsquo;s now <a href=https://cloud.google.com/binary-authorization/docs/making-attestations#create_an_attestation_with_a-based_pkix_signature>create an attestation with a Cloud Key Management Service-based PKIX signature</a>:</p><pre tabindex=0><code>imageName=$registryName/hello-world:latest
imageToAttest=$(gcloud artifacts docker images describe $imageName --format=&#39;get(image_summary.fully_qualified_digest)&#39;)
gcloud beta container binauthz attestations sign-and-create \
    --project=$projectId \
    --artifact-url=$imageToAttest \
    --attestor=$attestorName \
    --attestor-project=$attestorProjectId \
    --keyversion-project=$kmsKeyProjectId \
    --keyversion-location=$kmsKeyLocation \
    --keyversion-keyring=$kmsKeyringName \
    --keyversion-key=$kmsKeyName \
    --keyversion=$kmsKeyVersion
</code></pre><p>If you would like to run this exact same command above from within Cloud Build, so you will need to update the IAM roles of its service account:</p><pre tabindex=0><code>projectId=FIXME
projectNumber=&#34;$(gcloud projects describe $projectId --format=&#39;get(projectNumber)&#39;)&#34;
cloudBuildSa=$projectNumber@cloudbuild.gserviceaccount.com
roles=&#34;roles/binaryauthorization.attestorsViewer roles/cloudkms.signerVerifier roles/containeranalysis.notes.attacher&#34;
for r in $roles; do gcloud projects add-iam-policy-binding $projectId --member &#34;serviceAccount:$cloudBuildSa&#34; --role $r; done
</code></pre><p><em>Note: Shopify in collaboration with Google, just released the <a href=https://cloud.google.com/blog/products/devops-sre/introducing-voucher-service-help-secure-container-supply-chain><code>voucher</code> project</a> to add more security with your BinAuthz Attestation creation during your CI/CD pipeline.</em></p><h2 id=deploy-a-signed-container>Deploy a signed container
<a href=#deploy-a-signed-container class=h-anchor aria-hidden=true>#</a></h2><p>Last step is to actually <a href=https://cloud.google.com/binary-authorization/docs/deploying-containers>deploy the container on GKE</a>, you will need to get the <code>digest</code> instead of the <code>tag</code> like we did earlier with the <code>imageToAttest</code> variable.</p><p>That&rsquo;s a wrap! Binary Authorization allows to add more security in your CI/CD pipeline with more control on you GKE clusters with container registries whitelisting as well as allowing only container images with a valid attestation. And all of this with any container registries (even outside GCP) because at the end of the day, that&rsquo;s just Attestor/Attestation on GCP on any container images digest (whereever this container image is) ;)</p><p>Further and complementary resources:</p><ul><li><a href=https://cloud.google.com/security/binary-authorization-for-borg/>Binary Authorization for Borg: how Google verifies code provenance and implements code identity</a></li><li><a href=https://youtu.be/UkzfQvLpI0M>End-To-End Security and Compliance for Your Kubernetes Software Supply Chain (Cloud Next &lsquo;19)</a></li><li><a href=https://codelabs.developers.google.com/codelabs/cloud-binauthz-intro/index.html#0>Codelab: Securing Your GKE Deployments with Binary Authorization</a></li><li><a href=https://cloud.google.com/binary-authorization/pricing>Binary Authorization pricing</a></li><li><a href=https://cloud.google.com/binary-authorization/docs/securing-with-vpcsc>Securing with VPC Service Controls</a></li></ul><p>Hope you enjoyed that one, happy sailing, stay safe!</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/2020/11/online-boutique-demo/><span class=button__icon>←</span>
<span class=button__text>online boutique demo</span></a></span>
<span class="button next"><a href=/posts/2020/10/demo-bank/><span class=button__text>demo bank on gke</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2023 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></body></html>