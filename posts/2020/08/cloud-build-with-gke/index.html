<!doctype html><html lang=en><head><title>build and deploy a containerized app on gke with cloud build ::
always up, always on</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Today we will see how to build and deploy a containerized app on GKE by leveraging Google Cloud Build.
We will first setup the Continuous Integration (CI) part to build and push the containerized app in Google Artifact Registry and then we will setup the Continuous Delivery (CD) part to eventually deploy this containerized app on GKE.
Here is the setup of the context for the further considerations throughout this blog article."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://mathieu-benoit.github.io/myblog/posts/2020/08/cloud-build-with-gke/><link rel=stylesheet href=https://mathieu-benoit.github.io/myblog/assets/style.css><link rel=stylesheet href=https://mathieu-benoit.github.io/myblog/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://mathieu-benoit.github.io/myblog/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://mathieu-benoit.github.io/myblog/img/favicon.png><link href=https://mathieu-benoit.github.io/myblog/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/myblog/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/myblog/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/myblog/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/myblog/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/myblog/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="build and deploy a containerized app on gke with cloud build"><meta name=twitter:description content="let's see how to use google cloud build to build and deploy a containerized app on gke"><meta property="og:title" content="build and deploy a containerized app on gke with cloud build"><meta property="og:description" content="let's see how to use google cloud build to build and deploy a containerized app on gke"><meta property="og:type" content="article"><meta property="og:url" content="https://mathieu-benoit.github.io/myblog/posts/2020/08/cloud-build-with-gke/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-10T00:00:00+00:00"><meta property="article:modified_time" content="2020-08-10T00:00:00+00:00"><meta property="og:site_name" content="always up, always on"><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/myblog/about/>about</a></li><li><a href=/myblog/presentations/>presentations</a></li><li><a href=/myblog/tags/>tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/myblog/about/>about</a></li><li><a href=/myblog/presentations/>presentations</a></li><li><a href=/myblog/tags/>tags</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>build and deploy a containerized app on gke with cloud build</h1><div class=post-meta><span class=post-date>2020-08-10</span></div><span class=post-tags><a href=https://mathieu-benoit.github.io/myblog/tags/gcp/>#gcp</a>&nbsp;
<a href=https://mathieu-benoit.github.io/myblog/tags/security/>#security</a>&nbsp;
<a href=https://mathieu-benoit.github.io/myblog/tags/containers/>#containers</a>&nbsp;
<a href=https://mathieu-benoit.github.io/myblog/tags/kubernetes/>#kubernetes</a>&nbsp;</span><div class=post-content><p><img src=https://cloud.google.com/container-registry/images/builder.png alt="Logo of the Google Cloud Build service.">
Today we will see how to build and deploy a containerized app on GKE by leveraging <a href=https://cloud.google.com/cloud-build/>Google Cloud Build</a>.</p><p>We will first setup the <a href=#ci>Continuous Integration (CI)</a> part to build and push the containerized app in Google Artifact Registry and then we will setup the <a href=#cd>Continuous Delivery (CD)</a> part to eventually deploy this containerized app on GKE.</p><p>Here is the setup of the context for the further considerations throughout this blog article. The containerized app here will be my own blog:</p><pre tabindex=0><code>projectId=FIXME # ID of an existing project
gcloud config set project $projectId
gcloud services enable cloudbuild.googleapis.com
gcloud services enable artifactregistry.googleapis.com
location=us-east4
registryName=containers
gcloud artifacts repositories create $registryName \
    --location $location \
    --repository-format docker
git clone --recurse-submodules https://github.com/mathieu-benoit/myblog
cd myblog
</code></pre><p><em>Important remark: when we enable the <code>cloudbuild.googleapis.com</code> API on the current project, the associated <a href=https://cloud.google.com/cloud-build/docs/securing-builds/configure-access-for-cloud-build-service-account>Cloud Build Service Account</a> is created. You could see <a href=https://cloud.google.com/cloud-build/docs/cloud-build-service-account>here the list of its default roles and permissions</a>. For example it has the <code>artifactregistry.*</code> roles allowing it to <a href=https://cloud.google.com/artifact-registry/docs/access-control#permissions>push container images in Google Artifact Registry</a>.</em></p><h1 id=ci>CI
<a href=#ci class=h-anchor aria-hidden=true>#</a></h1><pre tabindex=0><code>appName=myblog
imageName=$registryHostName/$projectId/$registryName/$appName:7
cat &gt; cloudbuild-ci.yaml &lt;&lt;EOF
steps:
- name: gcr.io/cloud-builders/docker
  args: [&#39;build&#39;, &#39;-t&#39;, &#39;$imageName&#39;, &#39;.&#39;]
- name: gcr.io/cloud-builders/docker
  args: [&#39;push&#39;, &#39;$imageName&#39;]
EOF

gcloud builds submit \
    --config cloudbuild-ci.yaml \
    .

gcloud builds list
gcloud artifacts docker images list $location-docker.pkg.dev/$projectId/$registryName
gcloud artifacts docker tags list $location-docker.pkg.dev/$projectId/$registryName/$appName
</code></pre><p>And that&rsquo;s it, with 2 steps we are able to manually use Google Cloud Build to build and push a containerized app in Google Container Registry. We are using here the built-in <code>gcr.io/cloud-builders/docker</code> step wich is a container, you could find <a href=https://github.com/GoogleCloudPlatform/cloud-builders>here the list of the other built-in builder images</a> or the <a href=https://cloud.google.com/cloud-build/docs/configuring-builds/use-community-and-custom-builders>community-contributed builders and custom builders</a> or even the <a href=https://cloud.google.com/cloud-build/docs/interacting-with-dockerhub-images>Docker Hub images</a>. In addition to this, you may want to <a href=https://cloud.google.com/cloud-build/docs/configuring-builds/substitute-variable-values>substitute variable values</a> in your build config.</p><p>To be able to properly setup a Continuous Integration setup you will need to define the appropriate trigger with Google Cloud Build, in my case it will be a <a href=https://cloud.google.com/cloud-build/docs/automating-builds/create-github-app-triggers>GitHub App trigger</a>:</p><pre tabindex=0><code>gcloud beta builds triggers create github \
    --repo-name=$appName \
    --repo-owner=mathieu-benoit \
    --branch-pattern=&#34;master&#34; \
    --build-config=cloudbuild-ci.yaml
</code></pre><p>Another feature you may want to leverage with your container registry is <a href=https://cloud.google.com/artifact-registry/docs/analysis>Container Analysis</a></p><pre tabindex=0><code>gcloud services enable containeranalysis.googleapis.com
gcloud services enable containerscanning.googleapis.com
</code></pre><p>From there, the vulnerabilities scans will be in place as soon as you will push an image in the container registry. See the associated pricing page for this feature <a href=https://cloud.google.com/artifact-registry/pricing>here</a>. You could check the result of the scan by re-running this command <code>gcloud artifacts docker images list $location-docker.pkg.dev/$projectId/$registryName --show-occurrences</code> and look at the value of the <code>VULNERABILITIES</code> column.</p><p>I love the fact that the <a href=https://cloud.google.com/cloud-build/docs/build-config>build config definition is very light and easy to understand</a>, for example no extra fields to define a step or to do conditions, dependencies with other build configs, etc. You may have other experiences with other CI/CD tools with Azure DevOps and feel like me that this could be a limitation. But at the end of the day, isn&rsquo;t it better to have few features instead of a ton of them with multiple ways to accomplish what you are trying to do? Here, I haven&rsquo;t felt yet to be lost or that I was looking for what is the best way to do something, it seems pretty straight forward and powerful enough. For example, how to add conditions on a Git branch or other variables or context? Actually, you could either have different build config definitions (YAML or JSON files), different triggers based on the Git branch or you could also have more control with bash scripts at any step to be more flexible.</p><h1 id=cd>CD
<a href=#cd class=h-anchor aria-hidden=true>#</a></h1><p>Now let&rsquo;s deploy this containerized app on an existing GKE cluster in the same project after granting the <code>roles/container.developer</code> role to the Cloud Build Service Account:</p><pre tabindex=0><code>gkeName=FIXME
gkeZone=FIXME

projectNumber=&#34;$(gcloud projects describe $projectId --format=&#39;get(projectNumber)&#39;)&#34;
gcloud projects add-iam-policy-binding $projectNumber \
    --member=serviceAccount:$projectNumber@cloudbuild.gserviceaccount.com \
    --role=roles/container.developer

sed -i &#34;s,CONTAINER_IMAGE_NAME,$imageName,&#34; k8s/deployment.yaml

cat &gt; cloudbuild-cd.yaml &lt;&lt;EOF
steps:
- name: &#39;gcr.io/cloud-builders/kubectl&#39;
  args: [&#39;apply&#39;, &#39;-f&#39;, &#39;k8s/&#39;, &#39;-n&#39;, &#39;$appName&#39;]
  env:
  - &#39;CLOUDSDK_COMPUTE_ZONE=$gkeZone&#39;
  - &#39;CLOUDSDK_CONTAINER_CLUSTER=$gkeName&#39;
EOF

gcloud builds submit \
    --config cloudbuild-cd.yaml \
    .

gcloud builds list
gcloud container clusters get-credentials --project=$projectId --zone=$zoneName $gkeName
kubectl get all -n $appName
</code></pre><p>And that&rsquo;s it, just 1 step and our container image is deployed in GKE by leveraging our Kubernetes manifests! Because we provide both <code>CLOUDSDK_COMPUTE_ZONE</code> and <code>CLOUDSDK_CONTAINER_CLUSTER</code> environment variables, the <code>gcr.io/cloud-builders/kubectl</code> step is doing a <code>gcloud container clusters get-credentials</code> behind the scene for us before running the actual <code>kubectl</code> command. Anyway you could use this step/command for any Kubernetes cluster anywhere, but here there is a seamless and secure way to retrieve the GKE&rsquo;s kubeconfig.</p><p>The GKE cluster is able to pull images from Artifact Registry because they are on the same Project, you could get more information <a href=https://cloud.google.com/artifact-registry/docs/integrate-gke>here</a>.</p><p>For information, if you have a <a href=https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept>Private GKE cluster</a> and an <a href=https://cloud.google.com/artifact-registry/docs/securing-with-vpc-sc>Artifact Registry with Service Perimeter</a>, Cloud Build doesn&rsquo;t support VPC Service Control but <a href=https://cloud.google.com/vpc-service-controls/docs/supported-products#build>there is an alternative by creating an access level</a>.</p><p><em>Extra goodies here, you could get a Cloud Build&rsquo;s status badge by leveraging this <code>badger</code> project: <a href=https://github.com/kelseyhightower/badger>kelseyhightower/badger</a>.</em></p><h1 id=final-thoughts>Final thoughts
<a href=#final-thoughts class=h-anchor aria-hidden=true>#</a></h1><p>You could find my final <a href=https://github.com/mathieu-benoit/myblog/blob/master/cloudbuild.yaml><code>cloudbuild.yaml</code> file in GitHub</a> leveraging what we have been discussing throughout this blog article and combining both the CI part as well as the CD part. Yes, I&rsquo;m having just one build config file for my blog and as soon as the container image is pushed to GCR, it will be then deployed in GKE, without any pause, approval, etc. But again, you could achieve those with different build config files or also having different strategies in place regarding Git branches and pull requests to manage different environments. You could also setup a <a href=https://www.weave.works/blog/what-is-gitops-really>GitOps approach</a> to manage the CD part within your GKE cluster and not having this second part handled by Cloud Build.</p><p>To conclude, that&rsquo;s for sure you could use your tools of choice for CI/CD like Azure DevOps, Jenkins, Spinnaker, etc. to interact with GCP via the <code>gcloud</code> SDK/CLI. Based on my experience with Azure DevOps, I feel that Cloud Build is lighter and very easy to use and simplify the experience and the maintenance of the build config files. And to be honest, I really think that the <a href=https://en.wikipedia.org/wiki/KISS_principle>&ldquo;Keep It Simple, Stupid&rdquo; principle</a> is key here. Furthermore, the integration of Cloud Build in GCP is helping for a seamless and secure integration with other GCP services.</p><p>Complementary and further resources:</p><ul><li><a href=https://cloud.google.com/docs/ci-cd>CI/CD on Google Cloud</a></li><li><a href=https://cloud.google.com/cloud-build/pricing>Cloud Build Pricing</a></li><li><a href=https://cloud.google.com/container-registry/pricing>Container Registry Pricing</a></li><li><a href=https://cloud.google.com/kubernetes-engine/pricing>GKE Pricing</a></li><li><a href=https://codelabs.developers.google.com/codelabs/cloud-builder-gke-continuous-deploy/index.html>CodeLabs - Achieve continuous deployment to Google Kubernetes Engine (GKE) with Cloud Build</a></li><li><a href=https://cloud.google.com/cloud-build/docs/kaniko-cache>Using Kaniko cache</a></li><li><a href=https://codelabs.developers.google.com/codelabs/cloud-binauthz-intro/>Securing Your GKE Deployments with Binary Authorization</a></li><li><a href=https://github.blog/2020-08-04-github-actions-self-hosted-runners-on-google-cloud/>GitHub Actions self-hosted runners on Google Cloud</a></li></ul><p>Hope you enjoyed this blog article, happy CI/CD and sailing with Cloud Build and GKE! ;)</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://mathieu-benoit.github.io/myblog/posts/2020/08/cloud-operations-with-gke/><span class=button__icon>←</span>
<span class=button__text>cloud operations with gke</span></a></span>
<span class="button next"><a href=https://mathieu-benoit.github.io/myblog/posts/2020/08/second-week-with-gcp/><span class=button__text>my second week with gcp</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2023 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://mathieu-benoit.github.io/myblog/assets/main.js></script>
<script src=https://mathieu-benoit.github.io/myblog/assets/prism.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></body></html>