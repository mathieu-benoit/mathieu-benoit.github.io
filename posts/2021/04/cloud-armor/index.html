<!doctype html><html lang=en><head><title>cloud armor to protect your apps deployed on gke ::
always up, always on</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Google Cloud Armor helps protect your applications and websites against denial of service (DDOS) and web attacks (WAF).
Let&amp;rsquo;s see in actions how we could leverage Cloud Armor with GKE.
Cloud Armor policies # First, we need to define a security policy, the following example uses a preconfigured rule to mitigate cross-site scripting (XSS) attacks:
securityPolicyName=&amp;#34;my-security-policy&amp;#34; gcloud compute security-policies create $securityPolicyName \ --description &amp;#34;Block XSS attacks&amp;#34; gcloud compute security-policies rules create 1000 \ --security-policy $securityPolicyName \ --expression &amp;#34;evaluatePreconfiguredExpr(&amp;#39;xss-stable&amp;#39;)&amp;#34; \ --action &amp;#34;deny-403&amp;#34; \ --description &amp;#34;XSS attack filtering&amp;#34; Google Cloud Armor&amp;rsquo;s preconfigured WAF rules (OWASP Top 10 mitigation, etc."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/2021/04/cloud-armor/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon.png><link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="cloud armor to protect your apps deployed on gke"><meta name=twitter:description content="let's see how you could protect your apps deployed on gke against denial of service and web attacks"><meta property="og:title" content="cloud armor to protect your apps deployed on gke"><meta property="og:description" content="let's see how you could protect your apps deployed on gke against denial of service and web attacks"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2021/04/cloud-armor/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-30T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-30T00:00:00+00:00"><meta property="og:site_name" content="always up, always on"><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>cloud armor to protect your apps deployed on gke</h1><div class=post-meta><span class=post-date>2021-04-30</span></div><span class=post-tags><a href=/tags/security/>#security</a>&nbsp;
<a href=/tags/gcp/>#gcp</a>&nbsp;
<a href=/tags/kubernetes/>#kubernetes</a>&nbsp;
<a href=/tags/service-mesh/>#service-mesh</a>&nbsp;</span><div class=post-content><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/w6Z5Ps0rXvk style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="What is Cloud Armor in a one-pager"></iframe></div><blockquote><p><a href=https://cloud.google.com/armor>Google Cloud Armor</a> helps protect your applications and websites against denial of service (DDOS) and web attacks (WAF).</p></blockquote><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/oXJ68Sa8jfU style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="How You Can Protect Your Web Sites and Applications with Google Cloud Armor"></iframe></div><p>Let&rsquo;s see in actions how we could leverage Cloud Armor with GKE.</p><h2 id=cloud-armor-policies>Cloud Armor policies
<a href=#cloud-armor-policies class=h-anchor aria-hidden=true>#</a></h2><p>First, we need to define a <a href=https://cloud.google.com/armor/docs/configure-security-policies>security policy</a>, the following example uses a preconfigured rule to mitigate cross-site scripting (XSS) attacks:</p><pre tabindex=0><code>securityPolicyName=&#34;my-security-policy&#34;
gcloud compute security-policies create $securityPolicyName \
    --description &#34;Block XSS attacks&#34;
gcloud compute security-policies rules create 1000 \
    --security-policy $securityPolicyName \
    --expression &#34;evaluatePreconfiguredExpr(&#39;xss-stable&#39;)&#34; \
    --action &#34;deny-403&#34; \
    --description &#34;XSS attack filtering&#34;
</code></pre><blockquote><p>Google Cloud Armor&rsquo;s <a href=https://cloud.google.com/armor/docs/rule-tuning>preconfigured WAF rules</a> (OWASP Top 10 mitigation, etc.) can be added to a security policy to detect and deny unwelcome layer 7 requests containing SQLi or XSS attempts. Google Cloud Armor detects malicious requests and drops them at the edge of Google&rsquo;s infrastructure. The requests are not proxied to the backend service, regardless of where the backend service is deployed.</p></blockquote><p>To analyze suspicious requests you can enable Cloud Armor’s <a href=https://cloud.google.com/armor/docs/request-logging>verbose logging</a> capability in the relevant policy. With verbose logging enabled, Cloud Armor’s logs will contain additional information about where in the incoming request the suspicious signature appeared as well as a snippet of the suspicious signature and the field it appeared in.</p><pre tabindex=0><code>gcloud compute security-policies update $securityPolicyName \
    --log-level=VERBOSE
</code></pre><p>We could also leverage the <a href=https://cloud.google.com/armor/docs/adaptive-protection-use-cases>Adaptive Protection</a> feature currently in Preview.</p><blockquote><p>The most common use case for Adaptive Protection is detecting and responding to L7 DDoS attacks such as HTTP GET floods, HTTP POST floods, or other high frequency HTTP activities. L7 DDoS attacks often start relatively slow and grow in intensity over time. By the time humans or automated spike detection mechanisms detect an attack, it is likely to be high in intensity and already having a strong negative impact on the application.</p></blockquote><pre tabindex=0><code>gcloud compute security-policies update $securityPolicyName \
    --enable-layer7-ddos-defense
</code></pre><p>From here, you could attach this security policy to any <a href=https://cloud.google.com/armor/docs/configure-security-policies#attach-policies><code>backend-service</code></a>. The next sections will walk your through how to do that with GKE.</p><h2 id=cloud-native-load-balancer-with-gke>Cloud-native load balancer with GKE
<a href=#cloud-native-load-balancer-with-gke class=h-anchor aria-hidden=true>#</a></h2><p>The default load balancer for a <code>Service</code> or an <code>Ingress</code> on GKE is the external TCP/UDP (L4) load balancer, what we want to do here, is to expose them via an <a href=https://cloud.google.com/kubernetes-engine/docs/concepts/ingress>external HTTP(S) load balancer (L7)</a>. The latter provides integration with edge services like Identity-Aware Proxy (IAP), Google Cloud Armor, and Cloud CDN, as well as a globally distributed network of edge proxies. For this, you need to provision your GKE cluster with the <code>--enable-ip-aliases</code> parameter, then add the <code>cloud.google.com/neg: '{"ingress": true}'</code> annotation on your <code>Service</code> and finally have an <code>Ingress</code> to <a href=https://cloud.google.com/kubernetes-engine/docs/concepts/service-networking#understanding_load_balancing>actually generate the necessary resources underneath</a>.</p><h2 id=cloud-armor-in-front-of-gke-ingress>Cloud Armor in front of GKE Ingress
<a href=#cloud-armor-in-front-of-gke-ingress class=h-anchor aria-hidden=true>#</a></h2><p>Once you have configured a Google Cloud Armor security policy, you can <a href=https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-features#cloud_armor>reference it using a <code>BackendConfig</code></a>:</p><pre tabindex=0><code>apiVersion: cloud.google.com/v1
kind: BackendConfig
metadata:
  name: my-backendconfig
spec:
  securityPolicy:
    name: $securityPolicyName
</code></pre><p>Then associate this <code>BackendConfig</code> to your <code>Service</code> with the <code>neg</code> annotation:</p><pre tabindex=0><code>apiVersion: v1
kind: Service
metadata:
  name: my-service
  annotations:
    cloud.google.com/neg: &#39;{&#34;ingress&#34;: true}&#39;
    cloud.google.com/backend-config: &#39;{&#34;default&#34;: &#34;my-backendconfig&#34;}&#39;
...
</code></pre><p>Finally we could deploy the <code>Ingress</code> which will create the GCLB, etc.</p><pre tabindex=0><code>apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: my-ingress
spec:
  backend:
    serviceName: my-service
...
</code></pre><p>From here, your Ingress is now protected by Cloud Armor, you could test the associated public IP generated: <code>kubectl get ingress my-ingress</code>.</p><h2 id=cloud-armor-in-front-of-istio-or-anthos-service-mesh>Cloud Armor in front of Istio or Anthos Service Mesh
<a href=#cloud-armor-in-front-of-istio-or-anthos-service-mesh class=h-anchor aria-hidden=true>#</a></h2><p>Deploying external L7 load balancing outside of the mesh along with a mesh ingress layer offers significant advantages, especially for internet traffic. Even though Anthos Service Mesh (ASM) and Istio ingress gateways provide advanced routing and traffic management in the mesh, some functions are better served at the edge of the network. Taking advantage of internet-edge networking through Google Cloud&rsquo;s External HTTP(S) Load Balancing might provide significant performance, reliability, or security-related benefits over mesh-based ingress.</p><p><img src=https://cloud.google.com/architecture/images/exposing-service-mesh-apps-through-gke-ingress-topology.svg alt="Illustration of the L7 load balancing in front of the Service Mesh on GKE."></p><p>To accomplish this with ASM we need to adapt a little bit the setup we previously discussed.</p><p>The <code>BackendConfig</code> needs to be adjusted by specifying custom health checks for the mesh ingress proxies. Anthos Service Mesh and Istio expose their <a href=https://istio.io/latest/docs/ops/deployment/requirements/#ports-used-by-istio>sidecar proxy health checks</a> on port 15021 at the <code>/healthz/ready</code> path. Custom health check parameters are required because the serving ports (80 and 443) of mesh ingress proxies is different from their health check port (15021).</p><pre tabindex=0><code>apiVersion: cloud.google.com/v1
kind: BackendConfig
metadata:
  name: ingress-backendconfig
spec:
  healthCheck:
    requestPath: /healthz/ready
    port: 15021
    type: HTTP
  securityPolicy:
    name: $securityPolicyName
</code></pre><p>Then, we need to create an <code>IstioOperator</code> overlay file which will be used later when we will run the <code>asmcli</code> script:</p><pre tabindex=0><code>cat &lt;&lt;EOF &gt; ingress-backendconfig-operator.yaml
---
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  profile: empty # Do not install CRDs or the control plane
  components:
    ingressGateways:
    - name: asm-ingressgateway
      namespace: asm-ingress
      enabled: true
      label:
        # Set a unique label for the gateway. This is required to ensure Gateways
        # can select this workload
        asm: ingressgateway
      k8s:
          service:
            type: ClusterIP
          serviceAnnotations:
            cloud.google.com/backend-config: &#39;{&#34;default&#34;: &#34;ingress-backendconfig&#34;}&#39;
            cloud.google.com/neg: &#39;{&#34;ingress&#34;: true}&#39;
  values:
    gateways:
      istio-ingressgateway:
        # Enable gateway injection
        injectionTemplate: gateway
EOF
</code></pre><p>And now we could run the <a href=https://cloud.google.com/service-mesh/docs/unified-install/install><code>asmcli</code></a> script:</p><pre tabindex=0><code>./asmcli \
    --project_id ${PROJECT} \
    --cluster_name ${CLUSTER_NAME} \
    --cluster_location ${CLUSTER_LOCATION} \
    --enable_all \
    --custom_overlay ingress-backendconfig-operator.yaml
</code></pre><p>Here, you could make sure that everything is well deployed by running those commands:</p><pre tabindex=0><code>kubectl wait --for=condition=available --timeout=600s deployment --all -n istio-system
kubectl wait --for=condition=available --timeout=600s deployment --all -n asm-system
kubectl wait --for=condition=available --timeout=600s deployment --all -n asm-ingress
</code></pre><p>Finally we could deploy the <code>Ingress</code> in the <code>asm-ingress</code> namespace which will create the GCLB, etc.</p><pre tabindex=0><code>cat &lt;&lt;EOF &gt; asm-ingressgateway-ingress.yaml
kind: Ingress
metadata:
  name: asm-ingressgateway
  namespace: asm-ingress
spec:
  defaultBackend:
    service:
      name: asm-ingressgateway
      port:
        number: 80
  rules:
  - http:
      paths:
      - path: /*
        pathType: ImplementationSpecific
        backend:
          service:
            name: asm-ingressgateway
            port:
              number: 80
EOF
kubectl apply -f asm-ingressgateway-ingress.yaml
</code></pre><p>From here, your ASM&rsquo;s Ingress Gateway is now protected by Cloud Armor, you could test the associated public IP generated: <code>kubectl get ingress asm-ingressgateway -n asm-ingress</code>.</p><p>If you are looking for more advanced scenario with this setup, here you are:</p><ul><li><a href=https://cloud.google.com/architecture/exposing-service-mesh-apps-through-gke-ingress>From edge to mesh: Exposing service mesh applications through GKE Ingress</a></li><li><a href=/posts/2021/11/asm-security/>Secure your apps and your cluster with Anthos Service Mesh</a></li></ul><h2 id=cloud-logging-on-http-load-balancer>Cloud Logging on HTTP Load Balancer
<a href=#cloud-logging-on-http-load-balancer class=h-anchor aria-hidden=true>#</a></h2><p>An important piece from here is to have access to the <a href=https://cloud.google.com/armor/docs/configure-security-policies#enabling_https_request_logging>Google Cloud Armor logs</a> by security policy name, match rule priority, associated action, and related information logged as part of logging for HTTP(S) Load Balancing.</p><p>Here is the <code>gcloud</code> command you could run to get the associated <code>DENY</code> requests:</p><pre tabindex=0><code>filter=&#34;resource.type=\&#34;http_load_balancer\&#34; &#34;\
&#34;jsonPayload.enforcedSecurityPolicy.name=\&#34;${securityPolicyName}\&#34; &#34;\
&#34;jsonPayload.enforcedSecurityPolicy.outcome=\&#34;DENY\&#34;&#34;

gcloud logging read --project $projectId &#34;$filter&#34;
</code></pre><p><em>Note: in the output, you could look at the fields <code>userAgent</code>, <code>requestMethod</code> and <code>requestUrl</code> to see what kind of attacks you are now blocking.</em></p><h2 id=further-and-complementary-resources>Further and complementary resources
<a href=#further-and-complementary-resources class=h-anchor aria-hidden=true>#</a></h2><ul><li><a href=https://cloud.google.com/architecture/owasp-top-ten-mitigation>OWASP Top 10 mitigation options on Google Cloud</a></li><li><a href=https://services.google.com/fh/files/misc/esg_google_waap_wp.pdf>Meeting the Challenges of Securing Modern Web Applications with WAAP</a></li><li><a href=https://cloud.google.com/blog/products/networking/using-cloud-armor-and-cloud-cdn-with-your-google-load-balancer>Better together: Google Cloud Load Balancing, Cloud CDN, and Google Cloud Armor</a></li><li><a href="https://www.qwiklabs.com/focuses/1232?parent=catalog">Qwiklabs - HTTP Load Balancer with Cloud Armor</a></li><li><a href=https://cloud.google.com/architecture/exposing-service-mesh-apps-through-gke-ingress>From edge to mesh: Exposing service mesh applications through GKE Ingress</a></li><li><a href=https://cloud.google.com/armor/docs/managed-protection-overview#standard_versus_plus>Google Cloud Armor Standard versus Managed Protection Plus</a></li><li><a href=https://cloud.google.com/armor/pricing>Cloud Armor pricing</a></li><li><a href=https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-features>GKE Ingress features comparison</a></li><li><a href=https://cloud.google.com/blog/products/identity-security/identifying-and-protecting-against-the-largest-ddos-attacks>Exponential growth in DDoS attack volumes</a></li></ul><p>That&rsquo;s a wrap! That&rsquo;s how you are adding more security in front of your public endpoints against denial of service and web attacks.</p><p>Hope you enjoyed that one, stay safe out there, cheers!</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/2021/07/crfa/><span class=button__icon>←</span>
<span class=button__text>mix both internal and external load balancers to expose your crfa services</span></a></span>
<span class="button next"><a href=/posts/2021/04/gke-cilium/><span class=button__text>ebpf and cilium, to bring more security and more networking capabilities in gke</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2023 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></body></html>