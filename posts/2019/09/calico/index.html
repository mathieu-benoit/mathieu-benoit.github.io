<!doctype html><html lang=en><head><title>kubernetes network policies, how to secure the communications between your pods ::
always up, always on</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Update on October 17th, 2019, this blog article has been promoted and published on the official Microsoft&amp;rsquo;s Open Source blog there: Tutorial: Calico Network Policies with Azure Kubernetes Service.
On May 2019, Network Policies on AKS was announced GA:
A user-defined network policy feature in AKS enables secure network segmentation within Kubernetes. This feature also allows cluster operators to control which pods can communicate with each other and with resources outside the cluster."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://mathieu-benoit.github.io/posts/2019/09/calico/><link rel=stylesheet href=https://mathieu-benoit.github.io/assets/style.css><link rel=stylesheet href=https://mathieu-benoit.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://mathieu-benoit.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://mathieu-benoit.github.io/img/favicon.png><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://mathieu-benoit.github.io/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="kubernetes network policies, how to secure the communications between your pods"><meta name=twitter:description content="let's secure the communications between your pods with calico kubernetes network policies"><meta property="og:title" content="kubernetes network policies, how to secure the communications between your pods"><meta property="og:description" content="let's secure the communications between your pods with calico kubernetes network policies"><meta property="og:type" content="article"><meta property="og:url" content="https://mathieu-benoit.github.io/posts/2019/09/calico/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-30T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-30T00:00:00+00:00"><meta property="og:site_name" content="always up, always on"><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>kubernetes network policies, how to secure the communications between your pods</h1><div class=post-meta><span class=post-date>2019-09-30</span></div><span class=post-tags><a href=https://mathieu-benoit.github.io/tags/azure/>#azure</a>&nbsp;
<a href=https://mathieu-benoit.github.io/tags/containers/>#containers</a>&nbsp;
<a href=https://mathieu-benoit.github.io/tags/security/>#security</a>&nbsp;
<a href=https://mathieu-benoit.github.io/tags/kubernetes/>#kubernetes</a>&nbsp;</span><div class=post-content><p><em>Update on October 17th, 2019, this blog article has been promoted and published on the official Microsoft&rsquo;s Open Source blog there: <a href=https://cloudblogs.microsoft.com/opensource/2019/10/17/tutorial-calico-network-policies-with-azure-kubernetes-service/>Tutorial: Calico Network Policies with Azure Kubernetes Service</a>.</em></p><p>On May 2019, <a href=https://azure.microsoft.com/updates/user-defined-network-policy-in-azure-kubernetes-service-aks-is-now-available/>Network Policies on AKS was announced GA</a>:</p><blockquote><p><em>A user-defined network policy feature in AKS enables secure network segmentation within Kubernetes. This feature also allows cluster operators to control which pods can communicate with each other and with resources outside the cluster.
Network policy is generally available through the Azure native policy plug-in or through the community project Calico.</em></p></blockquote><p>I encourage you to give a read of this article too: <a href=https://azure.microsoft.com/blog/integrating-azure-cni-and-calico-a-technical-deep-dive>Integrating Azure CNI and Calico: A technical deep dive</a> where you will see all the concepts explained on a Networking perspective with AKS.
Furthermore here is the <a href=https://kubernetes.io/docs/tasks/administer-cluster/declare-network-policy>Kubernetes tutorial</a>, the <a href=https://docs.projectcalico.org/v3.9/security/calico-network-policy>Calico tutorial</a> and the <a href=https://docs.microsoft.com/azure/aks/use-network-policies>AKS tutorial</a> you could give a try to practice with those concepts.</p><p>Some gotchas here:</p><ul><li>By default, any pods could communicate with any other pods across namespaces within a Kubernetes cluster, it&rsquo;s by design.<ul><li>But <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies>Kubernetes Network Policies</a> will guarantee the &ldquo;Just Enough Access&rdquo; principle of your Security posture</li></ul></li><li>By default, there is no default plugin pre-installed with Kubernetes to actually apply such Network Policies<ul><li>You need to install this plugin, otherwise your Network Policies won&rsquo;t have any effect.</li></ul></li><li>With AKS, you have the option between <code>azure</code> or <code>calico</code> as your Network Policy plugin<ul><li>You could only define this at the cluster creation, update is not yet supported</li><li>With calico you could either use <code>kubenet</code> or <code>azure</code> as your CNI but for Azure CNI it&rsquo;s only with <code>azure</code> (not <code>kubenet</code>) as Network Policy plugin.</li><li>It&rsquo;s not yet supported for Windows nodes</li></ul></li><li>Both azure and calico Network Policy plugin are open source:<ul><li><code>azure</code>: <a href=https://github.com/Azure/azure-container-networking>https://github.com/Azure/azure-container-networking</a> </li><li><code>calico</code>: <a href=https://github.com/projectcalico/calico>https://github.com/projectcalico/calico</a><ul><li>AKS currently, as we speak, supports Calico version 3.5.0</li></ul></li></ul></li></ul><p>Because I love practicing while learning, here is a scenario where I was able to build 4 different Network Policies for this setup below:</p><ul><li>WEB is exposed and accessible publicly from the Internet</li><li>WEB talks to API</li><li>API talks to DB</li><li>Not any other exposures nor communications, just this.</li></ul><p><img src=https://github.com/mathieu-benoit/k8s-netpol/raw/master/db-api-web-deployments.png alt="Architecture diagram showing the interactions between the different apps and the kube-dns pod to illustrate the NetworkPolicies setup."></p><p>Let&rsquo;s have a look to share with you my learnings there!</p><p>First we need to provision a cluster with Network Policies enabled, in my case I will go ahead with Calico:</p><pre tabindex=0><code>az aks create \
    --network-policy calico
</code></pre><p>To start and illustrate this we need to deploy those Pods:</p><pre tabindex=0><code>ns=yournamespace
kubectl create ns $ns
kubectl config set-context --current --namespace $ns
kubectl apply \
    -f https://raw.githubusercontent.com/mathieu-benoit/k8s-netpol/master/db-api-web-deployments.yaml
</code></pre><p>You now have 3 Pods and 3 Services:</p><pre tabindex=0><code>kubectl get pod,svc -n $ns
</code></pre><p>We could check that WEB is publicly accessible:</p><pre tabindex=0><code>curl $(kubectl get svc web -o jsonpath=&#39;{.status.loadBalancer.ingress[0].ip}&#39;)
</code></pre><p>Our first test is to see that any pods could communicate with each others even externally, let&rsquo;s run few successful commands:</p><pre tabindex=0><code>kubectl run curl-$RANDOM \
    --image=radial/busyboxplus:curl \
    --rm \
    -it \
    --generator=run-pod/v1
# curl www.microsoft.com
# curl http://db:15984
# exit
</code></pre><p>Let&rsquo;s apply the first Network Policy that should be for any namespace, <a href="https://orca.tufin.io/netpol/?yaml=apiVersion:%20networking.k8s.io%2Fv1%0Akind:%20NetworkPolicy%0Ametadata:%0A3name:%20deny-all%0Aspec:%0A3podSelector:%20%7B%7D%0A3policyTypes:%0A3-%20Ingress%0A3-%20Egress">Deny all ingress and egress</a>!</p><pre tabindex=0><code>kubectl apply \
    -f https://raw.githubusercontent.com/mathieu-benoit/k8s-netpol/master/deny-all-netpol.yaml
</code></pre><p>We could check that WEB isn&rsquo;t anymore publicly accessible:</p><pre tabindex=0><code>curl --connect-timeout 2 $(kubectl get svc web -o jsonpath=&#39;{.status.loadBalancer.ingress[0].ip}&#39;)
</code></pre><p>Let&rsquo;s also re-run the two previous tests which should fail now:</p><pre tabindex=0><code>kubectl run curl-$RANDOM \
    --image=radial/busyboxplus:curl \
    --rm \
    -it \
    --generator=run-pod/v1
# curl --connect-timeout 2 www.microsoft.com
# curl --connect-timeout 2 http://db:15984
# exit
</code></pre><p>Actually no one could communicate from/to that namespace at this stage, that&rsquo;s what we want. Now let&rsquo;s be more granular and illustrate the &ldquo;Least Access&rdquo; and &ldquo;Just Enough Access&rdquo; Security Principles.</p><p>First, we want <a href="https://orca.tufin.io/netpol/?yaml=apiVersion:%20networking.k8s.io%2Fv1%0Akind:%20NetworkPolicy%0Ametadata:%0A3name:%20db-netpol%0Aspec:%0A3podSelector:%0A5matchLabels:%0A7app:%20db%0A3policyTypes:%0A3-%20Ingress%0A3ingress:%0A3-%20from:%0A5-%20podSelector:%0A9matchLabels:%0A11app:%20api%0A5ports:%0A6-%20port:%205984%0A8protocol:%20TCP">DB be accessible only from API on port 5984 and doesn&rsquo;t have access to anything</a>:</p><pre tabindex=0><code>kubectl apply \
    -f https://raw.githubusercontent.com/mathieu-benoit/k8s-netpol/master/db-netpol.yaml
</code></pre><p>Let&rsquo;s validate that DB doesn&rsquo;t have access to anything:</p><pre tabindex=0><code>kubectl run curl-$RANDOM \
    --image=radial/busyboxplus:curl \
    --labels app=db \
    --rm \
    -it \
    --generator=run-pod/v1 \
    -n $ns
# curl --connect-timeout 2 http://web:80
# curl --connect-timeout 2 www.microsoft.com
# exit
</code></pre><p>We now want <a href="https://orca.tufin.io/netpol/?yaml=apiVersion:%20networking.k8s.io%2Fv1%0Akind:%20NetworkPolicy%0Ametadata:%0A3name:%20api-netpol%0Aspec:%0A3podSelector:%0A5matchLabels:%0A7app:%20api%0A3policyTypes:%0A3-%20Ingress%0A3-%20Egress%0A3ingress:%0A3-%20from:%0A5-%20podSelector:%0A9matchLabels:%0A11app:%20web%0A5ports:%0A6-%20port:%203000%0A8protocol:%20TCP%0A3egress:%0A3-%20to:%0A5-%20podSelector:%0A9matchLabels:%0A11app:%20db%0A5ports:%0A6-%20port:%205984%0A8protocol:%20TCP%0A3-%20to:%0A5-%20namespaceSelector:%0A9matchLabels:%0A11name:%20kube-system%0A7podSelector:%0A9matchLabels:%0A11k8s-app:%20kube-dns%0A5ports:%0A6-%20port:%2053%0A8protocol:%20UDP">API having access only to DB on port 5984 and be accessible only from WEB on port 8080</a>:</p><pre tabindex=0><code>kubectl apply \
    -f https://raw.githubusercontent.com/mathieu-benoit/k8s-netpol/master/api-netpol.yaml
</code></pre><p>Actually we need also to do an extra action here by adding a Label on the kube-system Namespace (NetworkPolicies are all about Labels ;)):</p><pre tabindex=0><code>kubectl label ns kube-system name=kube-system
</code></pre><p>Let&rsquo;s validate that API has access to DB but doesn&rsquo;t have access to WEB nor Internet:</p><pre tabindex=0><code>kubectl run curl-$RANDOM \
    --image=radial/busyboxplus:curl \
    --labels app=api \
    --rm \
    -it \
    --generator=run-pod/v1

# curl http://db:15984
# curl --connect-timeout 2 http://web:80
# curl --connect-timeout 2 www.microsoft.com
# exit
</code></pre><p>And finally we want <a href="https://orca.tufin.io/netpol/?yaml=apiVersion:%20networking.k8s.io%2Fv1%0Akind:%20NetworkPolicy%0Ametadata:%0A3name:%20web-netpol%0Aspec:%0A3podSelector:%0A5matchLabels:%0A7app:%20web%0A3policyTypes:%0A3-%20Ingress%0A3-%20Egress%0A3ingress:%0A3-%20from:%20%5B%5D%0A5ports:%0A6-%20port:%2080%0A8protocol:%20TCP%0A3egress:%0A3-%20to:%0A5-%20podSelector:%0A9matchLabels:%0A11app:%20api%0A5ports:%0A6-%20port:%203000%0A8protocol:%20TCP%0A3-%20to:%0A5-%20namespaceSelector:%0A9matchLabels:%0A11name:%20kube-system%0A7podSelector:%0A9matchLabels:%0A11k8s-app:%20kube-dns%0A5ports:%0A6-%20port:%2053%0A8protocol:%20UDP">WEB having access only to API on port 3000 and be accessible only from Internet on port 80</a>:</p><pre tabindex=0><code>kubectl apply \
    -f https://raw.githubusercontent.com/mathieu-benoit/k8s-netpol/master/web-netpol.yaml
</code></pre><p>Let&rsquo;s validate that WEB has access to API but doesn&rsquo;t have access to DB or Internet:</p><pre tabindex=0><code>kubectl run curl-$RANDOM \
    --image=radial/busyboxplus:curl \
    --labels app=web \
    --rm \
    -it \
    --generator=run-pod/v1
# curl http://api:8080
# curl --connect-timeout 2 www.microsoft.com
# curl --connect-timeout 2 http://db:15984
# exit
</code></pre><p>We could check that WEB is publicly accessible again:</p><pre tabindex=0><code>curl $(kubectl get svc web -o jsonpath=&#39;{.status.loadBalancer.ingress[0].ip}&#39;)
</code></pre><p>Here you are! We have secured communications for our 3 Pods: WEB, API and DB by defining the very strict minimal requirements on that regard, nothing less and nothing more.</p><p>Some gotchas:</p><ul><li>It&rsquo;s all about Labels on Pods and Namespaces</li><li>It&rsquo;s not about Services nor the ports exposed there, it&rsquo;s about Pods&rsquo; ports</li><li>You could use podSelector and namespaceSelector</li><li>In one NetworkPolicy, you could combine multiple to: and multiple from:, therefore they will be applied as AND rules</li><li>Again, the scope is per Namespace,  but via the namespaceSelector for Ingress or Egress you could reference external Namespaces<ul><li>You could use <a href=https://docs.projectcalico.org/v3.9/reference/resources/globalnetworkpolicy>GlobalNetworkPolicy with Calico</a> to apply rules across Namespaces</li></ul></li><li>To be able to reach out to another Pod via its Service name exposure you need to add an Egress rule for the DNS resolver (with the label k8s-app=kube-dns) in the kube-system Namespace. We saw that we need to add a label name=kube-system on the kube-system Namespace.</li><li>Network Policy Engine is doing the union of all the rules, Rule1 OR Rule2 OR&mldr;</li><li>Default rules are for Ingress, as soon as you are adding Egress you need to specify this in the policyTypes: section</li></ul><p>Resources:</p><ul><li><a href=https://youtu.be/131_TIa_ftI>Secure traffic between pods using network policies in Azure Kubernetes Service (AKS) | Azure Friday</a></li><li><a href=https://youtu.be/3gGpMmYeEO8>Securing Cluster Networking with Network Policies - Ahmet Balkan, Google</a><ul><li><a href=https://github.com/ahmetb/kubernetes-network-policy-recipes>https://github.com/ahmetb/kubernetes-network-policy-recipes</a></li></ul></li><li><a href=https://medium.com/@reuvenharrison/an-introduction-to-kubernetes-network-policies-for-security-people-ba92dd4c809d>An Introduction to Kubernetes Network Policies for Security People</a></li><li><a href=https://orca.tufin.io/netpol>Kubernetes Network Policies Viewer</a></li></ul><p>Hope you enjoyed this blog article and this learning process and hope you will be able to leverage this for your own context and needs.</p><p>Cheers!</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://mathieu-benoit.github.io/posts/2019/11/ignite2019/><span class=button__icon>←</span>
<span class=button__text>ignite 2019, what's new with containers and kubernetes on azure?</span></a></span>
<span class="button next"><a href=https://mathieu-benoit.github.io/posts/2019/09/deploy-terraform-via-azure-pipelines/><span class=button__text>a recipe to deploy your azure resources with terraform via azure pipelines</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2023 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://mathieu-benoit.github.io/assets/main.js></script>
<script src=https://mathieu-benoit.github.io/assets/prism.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></body></html>