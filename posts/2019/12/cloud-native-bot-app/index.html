<!doctype html><html lang=en><head><title>my bot just became a cloud native app ::
always up, always on</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="On April 2018, I played for the first time with the Bot Framework, I got that idea to leverage such technologies and feature for my monthly &amp;ldquo;Azure News &amp;amp; Updates&amp;rdquo; blog article. It was a good opportunity for me to make my app a great conversationalist. At that time, I built this with Azure Functions v1, Bot Framework v3, static and not-compiled code in .NET Framework, I got issue with the cold start; none of this was cross-platform at that time&amp;hellip; Since then I have learned a lot about OSS, Docker and Kubernetes."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/2019/12/cloud-native-bot-app/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon.png><link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="my bot just became a cloud native app"><meta name=twitter:description content="let's leverage docker, helm, kubernetes and terraform to make your bot app more cloud native"><meta property="og:title" content="my bot just became a cloud native app"><meta property="og:description" content="let's leverage docker, helm, kubernetes and terraform to make your bot app more cloud native"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2019/12/cloud-native-bot-app/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-23T00:00:00+00:00"><meta property="article:modified_time" content="2019-12-23T00:00:00+00:00"><meta property="og:site_name" content="always up, always on"><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about/>about</a></li><li><a href=/presentations/>presentations</a></li><li><a href=/tags/>tags</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>my bot just became a cloud native app</h1><div class=post-meta><span class=post-date>2019-12-23</span></div><span class=post-tags><a href=/tags/azure/>#azure</a>&nbsp;
<a href=/tags/containers/>#containers</a>&nbsp;
<a href=/tags/kubernetes/>#kubernetes</a>&nbsp;
<a href=/tags/dotnet/>#dotnet</a>&nbsp;
<a href=/tags/terraform/>#terraform</a>&nbsp;
<a href=/tags/helm/>#helm</a>&nbsp;
<a href=/tags/azure-devops/>#azure-devops</a>&nbsp;</span><div class=post-content><p>On April 2018, I played for the first time with the Bot Framework, <a href=https://alwaysupalwayson.blogspot.com/2018/04/my-monthly-azure-news-updates-blog.html>I got that idea to leverage such technologies and feature for my monthly &ldquo;Azure News & Updates&rdquo; blog article</a>. It was a good opportunity for me to make my app <a href=https://alwaysupalwayson.blogspot.com/2018/03/make-your-apps-great-conversationalists.html>a great conversationalist</a>. At that time, I built this with Azure Functions v1, Bot Framework v3, static and not-compiled code in .NET Framework, I got issue with the cold start; none of this was cross-platform at that time&mldr; Since then I have learned a lot about OSS, Docker and Kubernetes. On that regard, why not modernizing my Bot with more Cloud Native Computing practices?!</p><p>Before trying to reinvent the wheel I found those following insightful and inspirational resources:</p><ul><li><a href=https://medium.com/@sozercan/deploying-microsoft-bot-framework-bots-using-kubernetes-on-azure-container-service-acs-ea5c6ffead1f>In 2017-01</a>, Sertaç Özercan used Docker, ACR and ACS to deploy his Bot in NodeJS</li><li><a href=https://itnext.io/building-a-kubernetes-deployment-pipeline-for-microsoft-bot-framework-part-1-ddbb9f6f1796>In 2018-02</a>, Jonathan Harrison used Docker, ARM Templates, AKS, Helm 2, Nginx, TravisCI to deploy his Bot in NodeJS</li><li><a href=https://medium.com/@AliMazaheri/building-a-chat-bot-using-azure-aks-and-bot-framework-bfa1f698cc3c>In 2018-09</a>, Ali Mazaheri used Docker, Draft, ACR and AKS to deploy his Bot in .NET Core 2</li><li><a href=https://github.com/microsoft/app-innovation-team/tree/master/1.%20labs/walkthrough-bot-dotnet>In 2019-03</a>, Roberto Cervantes used Docker, ACR, AKS, Helm 2, Nginx, Cert-Manager, Azure DevOps to deploy his Bot in .NET Core 2</li><li><a href=https://mybuild.techcommunity.microsoft.com/sessions/77153>In 2019-05</a>, Luis Antonio Beltran Prieto and Humberto Jaimes used Docker to deploy their Bot in .NET Core 2</li></ul><p><strong>Huge kudos to them</strong> for taking the time to share and document their knowledge and learnings!</p><p>From this and as we speak in December 2019, I have been able to leverage latest and greatest features and technologies to modernize and containerize my Bot, here below are few highlights and concepts you will be able to find with my own implementation:</p><p><img src=https://1.bp.blogspot.com/-ZvSZ8KCoQ9w/Xg0lnjh7ZnI/AAAAAAAAUls/zp9FgCt49GkUekauUqX4Ulowwl-zZtBmwCLcBGAsYHQ/s1600/FlowAndArchitecture.PNG alt="Architecture diagram showing the app and its interactions with the different technologies and services such as Terraform, Application Insights, Helm, AKS and Azure Search."></p><h1 id=net-core-31>.NET Core 3.1
<a href=#net-core-31 class=h-anchor aria-hidden=true>#</a></h1><p>I was able to implement my Bot with <a href=https://devblogs.microsoft.com/dotnet/announcing-net-core-3-1>.NET Core 3.1 just announced early December 2019</a>. That&rsquo;s the new LTS version, where performance is greatly improved, the garbage collector use less memory and this version has been hardened for Docker.</p><h1 id=docker-base-image>Docker base image
<a href=#docker-base-image class=h-anchor aria-hidden=true>#</a></h1><p>I&rsquo;m using the <a href=https://hub.docker.com/_/microsoft-dotnet-core-aspnet>mcr.microsoft.com/dotnet/core/aspnet</a> base image, you could find the entire list of tags available here: <a href=https://mcr.microsoft.com/v2/dotnet/core/aspnet/tags/list>https://mcr.microsoft.com/v2/dotnet/core/aspnet/tags/list</a>. If you don&rsquo;t know yet, base images of Microsoft related products are now published in the Microsoft Container Registry, <a href=https://devblogs.microsoft.com/dotnet/net-core-container-images-now-published-to-microsoft-container-registry/>read the story here</a>. Furthermore, I&rsquo;m using the alpine version of this base image in order to <a href=/posts/2019/11/scanning-containers-with-asc/>reduce the size of the image as well as the surface of threat</a> with such small alpine distribution. Notice also that I&rsquo;m not using <code>latest</code>, <code>3</code> nor <code>3.1</code> but explicitly <code>aspnet:3.1.0</code> and <code>sdk:3.1.100</code> versions to be able to update them accordingly as new versions will arrive.<br>The size of my image is now 112 MB.</p><h1 id=helm-3-and-helm-chart>Helm 3 and Helm chart
<a href=#helm-3-and-helm-chart class=h-anchor aria-hidden=true>#</a></h1><p><a href=/posts/2019/11/helm3/>Helm 3 went out in November 2019</a>, this major version got rid of Tiller, but that&rsquo;s not all! With this implementation I was able to build the associated Helm 3 chart, pushed it in Azure Container Registry (ACR) and deploy it in a Tiller-less Kubernetes cluster. Furthermore, this Helm chart contains all the Kubernetes objects the application needs to successfuly run on any Kubernetes cluster: <code>Deployment</code>, <code>Service</code>, <code>Ingress</code>, <code>Issuer</code>, <code>NetworkPolicies</code>, <code>Secrets</code> as well as its dependency with the Nginx Ingress Controller chart (see inside the <code>Chart.yaml</code>).</p><h1 id=azure-pipelines>Azure Pipelines
<a href=#azure-pipelines class=h-anchor aria-hidden=true>#</a></h1><p>Inspired by my blog article <a href=https://cloudblogs.microsoft.com/opensource/2018/11/27/tutorial-azure-devops-setup-cicd-pipeline-kubernetes-docker-helm>Tutorial: Using Azure DevOps to setup a CI/CD pipeline and deploy to Kubernetes</a> I was able to implement both CI/Build and CD/Release in YAML, to build the Docker image and Helm chart, push them in ACR to then trigger the deployment in AKS via Helm. In addition to that, I was able to leverage my blog article <a href=/posts/2019/09/deploy-terraform-via-azure-pipelines/>A recipe to deploy your Azure resources with Terraform via Azure DevOps</a> to combine my CI/CD with Terraform within the same Appplication&rsquo;s pipeline. I also added an <a href=https://docs.microsoft.com/azure/devops/pipelines/process/approvals>Approval/Check point between the Build/CI and Release/CD Stages</a> (note: it&rsquo;s a manual process for now).</p><p><img src=https://1.bp.blogspot.com/-s251aiDj80I/Xg5JBR9s_uI/AAAAAAAAUl4/yjUvRnN-Fkgey-RvynUbk76sCwXWEXNdwCLcBGAsYHQ/s1600/Capture.PNG alt="Screenshot of the summary of a successfull run of the Build and Release phases in Azure DevOps."></p><h1 id=kubernetes-ingress-controller>Kubernetes Ingress Controller
<a href=#kubernetes-ingress-controller class=h-anchor aria-hidden=true>#</a></h1><p>To be able to register the backend of your <a href=https://docs.microsoft.com/azure/bot-service>Azure Bot Service</a>, even if it could be hosted anywhere (literally), it should expose an HTTPS endpoint. In my case, I&rsquo;m exposing my Bot by Nginx as an Ingress Controller by deploying the <a href=https://kubernetes.github.io/ingress-nginx>ingress-nginx Helm chart</a>. I&rsquo;m also using the following annotation to add a DNS on my public Azure IP Address:<br>service.beta.kubernetes.io/azure-dns-label-name<br>Furthermore, I&rsquo;m leveraging the <a href=https://cert-manager.io>jetstack/cert-manager Helm chart</a> for generating my Certificate and configure my TLS termination.</p><p>You could find my GitHub Pull Request showing in details the implementation of the 5 topics mentioned above: <a href=https://github.com/mathieu-benoit/MyMonthlyBlogArticle.Bot/pull/10>https://github.com/mathieu-benoit/MyMonthlyBlogArticle.Bot/pull/10</a>. Furthermore, you will find this other GitHub PR where my Helm chart got enrich with more Kubernetes objects and Helm dependencies: <a href=https://github.com/mathieu-benoit/MyMonthlyBlogArticle.Bot/pull/18>https://github.com/mathieu-benoit/MyMonthlyBlogArticle.Bot/pull/18</a>.</p><h1 id=application-insights>Application Insights
<a href=#application-insights class=h-anchor aria-hidden=true>#</a></h1><p>To be able to get telemetry with this Bot like Requests, Exceptions, Response time, Search terms used, etc. I&rsquo;m leveraging <a href=https://github.com/mathieu-benoit/MyMonthlyBlogArticle.Bot/pull/19>Application Insights embedded in my Bot</a>.</p><h1 id=unit-tests>Unit Tests
<a href=#unit-tests class=h-anchor aria-hidden=true>#</a></h1><p>Unit Tests run within the Dockerfile and the results are published as part of the CI/Build in Azure Pipeline. This allows to run unit tests consistently whenever and wherever a docker build command runs. You could <a href=https://github.com/mathieu-benoit/MyMonthlyBlogArticle.Bot/pull/20>have a look at the associated GitHub PR I did for this</a>.</p><h1 id=terraform>Terraform
<a href=#terraform class=h-anchor aria-hidden=true>#</a></h1><p>At first when I implemented this Bot, <a href=https://github.com/mathieu-benoit/MyMonthlyBlogArticle.Bot/blob/oldversion/azure-deploy.json>I leveraged ARM Templates</a>, but my preference now is more with Terraform to accomplish Infrastructure-as-Code (IaC), so <a href=https://github.com/mathieu-benoit/MyMonthlyBlogArticle.Bot/pull/25>here is my GitHub PR for the implementation of this</a>. In my Azure Pipeline, I do terraform plan in the Build/CI Stage and do terraform apply in the Release/CD Stage.</p><p>Interesting stuffs, isn&rsquo;t it!?</p><p>Regarding the price, before this new implementation it was almost free with an Azure Functions in the backend because I don&rsquo;t have a lot of traffic, and actually I could still continue leverage Azure Functions, if I would like. But now, I have made the decision to do it with Kubernetes, to learn more about it, so it will cost me 3 Kubernetes Nodes (VMs), but I have other workloads running on that Kubernetes cluster so this cost is shared by multiple workloads. Furthermore, I have now common practices to deploy any workload consistently via Kubernetes APIs, so I&rsquo;m saving the cost for the deployments, the automation, the maintenance, etc. that&rsquo;s other invisible/implicit costs to take into account when comparing the real and concrete cost&mldr;</p><p>Great learnings for me! Feel free to leverage all of this for your own context and needs!</p><p>Cheers! ;)</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/2020/01/kured/><span class=button__icon>←</span>
<span class=button__text>flexible kured deployment with its helm chart</span></a></span>
<span class="button next"><a href=/posts/2019/11/scanning-containers-with-asc/><span class=button__text>scanning container images for vulnerabilities in acr with asc</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>always up, always on</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2023 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-J8536XT21V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-J8536XT21V",{anonymize_ip:!1})}</script></body></html>